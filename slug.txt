SLUG object is attached to each star particles, same as particle position, velocity, mass, and so on. You can check the declaration in Grid.h.
//
//  Particle data
//
  int    NumberOfParticles;
  FLOAT *ParticlePosition[MAX_DIMENSION];  // pointers to position arrays
  float *ParticleVelocity[MAX_DIMENSION];  // pointers to velocity arrays
  float *ParticleAcceleration[MAX_DIMENSION+1];  // 
  float *ParticleMass;                     // pointer to mass array
  PINT  *ParticleNumber;                   // unique identifier
  int   *ParticleType;                     // type of particle
  float *ParticleAttribute[MAX_NUMBER_OF_PARTICLE_ATTRIBUTES];
#ifdef USE_SLUG
  particle_object **ParticleObject;
#endif //End of USE_SLUG
I added new three files; particle_object.h: this declares particle_object class. This is just an abstract base class. particle_slug_object.h: this declares particle_slug_object class, a concrete derived class. This works as an interface between Enzo and SLUG. In this class, we construct slug_cluster object and access to their member functions. slug_cluster class is defined in SLUG. This draws stellar distribution from star particle mass. particle_slug_object.C: this defines particle_slug_object class. With this file, you can specify the IMF, stellar evolution track, spectral synthesiser, photometric filter, and yields table.
Example of calling SLUGâ€™s functions in Enzo;
//
// In star formation routine,
//
tg->ParticleObject[i] = static_cast<particle_object *>(new particle_slug_object);
float ActualParticleMass = tg->ParticleMass[i] * POW(CellWidthTemp, 3);
static_cast<particle_slug_object *> (tg->ParticleObject[i])->construct_cluster(ActualParticleMass);
//
//In stellar feedback routine,
//
float relativeTime = (Time - ParticleAttribute[0][i]) * TimeUnits / year; // Time unit in SLUG = yr.
static_cast<particle_slug_object *> (ParticleObject[i])->advance(relativeTime);

// the number of SNe
int curr_stoch_sn = static_cast<particle_slug_object *> (ParticleObject[i])->get_stoch_sn();

// ejected gas mass from stars
float curr_stellar_mass = static_cast<particle_slug_object *> (ParticleObject[i])->get_stellar_mass();

// ejected mass of Fe60
float curr_yield_Fe60 = static_cast<particle_slug_object *> (ParticleObject[i])->get_yields_Fe60();

// get ionising luminosity in 10^49 photons s^-1
s49_tot_slug[i] = (static_cast<particle_slug_object *> (ParticleObject[i])->get_photometry_QH0()) / 1e49;






 #include "typedefs.h"
 #include "global_data.h"
 #include "SortCompareFunctions.h"
+#ifdef USE_SLUG
+#include "particle_slug_object.h"
+#endif //End of USE_SLUG
 
 void my_exit(int status);
 
 
   int i, proc;
   int NumberOfSends;
+#ifdef USE_SLUG
+  int j, k, l, m;
+  int NumberOfSends2;
+  int TotalBufferSizeSoFar;
+#endif //End of USE_SLUG
 
   // In order to call Alltoallv, we need to sort the list by
   // destination processor
   MPI_Arg SendCount;
   MPI_Arg RecvCount;
   MPI_Arg stat;
+#ifdef USE_SLUG
+  MPI_Arg SendCount2;
+  MPI_Arg RecvCount2;
+#endif //End of USE_SLUG
 #endif /* USE_MPI */
 
   if (NumberOfProcessors > 1) {
     MPI_Arg *MPI_RecvListCount = new MPI_Arg[NumberOfProcessors];
     MPI_Arg *MPI_RecvListDisplacements = new MPI_Arg[NumberOfProcessors];
 
+#ifdef USE_SLUG
+    int *SendListCount = new int[NumberOfProcessors];
+    int *SendListCount2 = new int[NumberOfProcessors];
+    int *RecvListCount2 = new int[NumberOfProcessors];
+#endif //End of USE_SLUG
+
     int jjj;
 
     for (jjj = 0; jjj < NumberOfProcessors; jjj++) {
       RecvListCount[jjj] = 0;
+#ifdef USE_SLUG
+      RecvListCount2[jjj] = 0;
+#endif //End of USE_SLUG
       MPI_RecvListCount[jjj] = 0;
       MPI_RecvListDisplacements[jjj] = 0;
     }
 
+#ifdef USE_SLUG
+    NumberOfSends = 0;
+    NumberOfSends2 = 0;
+    int kkk = 0;
+    for (jjj = 0; jjj < NumberOfProcessors; jjj++) {
+      MPI_SendListDisplacements[jjj] = NumberOfSends2;
+      int particles_buffer_size = 0; 
+      for (int iii = 0; iii < NumberToMove[jjj]; iii++) {
+        particles_buffer_size += sizeof(particle_data) + sizeof(size_t);
+        if (SendList[kkk].object != NULL)
+          particles_buffer_size += static_cast<particle_slug_object *>(SendList[kkk].object)->buffer_size();
+        else
+          particles_buffer_size += 0;
+        kkk ++;
+      }
+      NumberOfSends += NumberToMove[jjj];
+      NumberOfSends2 += particles_buffer_size;
+      SendListCount[jjj] = NumberToMove[jjj];
+      SendListCount2[jjj] = particles_buffer_size;
+      MPI_SendListCount[jjj] = particles_buffer_size;
+    }
+#else
     NumberOfSends = 0;
     for (jjj = 0; jjj < NumberOfProcessors; jjj++) {
       MPI_SendListDisplacements[jjj] = NumberOfSends;
       NumberOfSends += NumberToMove[jjj];
       MPI_SendListCount[jjj] = NumberToMove[jjj];
     }
+#endif //End of USE_SLUG
 
     SendCount = 1;
     RecvCount = 1;
        Share the particle counts
     ******************************/
     
+#ifdef USE_SLUG
+    stat = MPI_Alltoall(SendListCount, SendCount, DataTypeInt,
+			RecvListCount, RecvCount, DataTypeInt, MPI_COMM_WORLD);
+    if (stat != MPI_SUCCESS) ENZO_FAIL("");
+    stat = MPI_Alltoall(SendListCount2, SendCount, DataTypeInt,
+	                RecvListCount2, RecvCount, DataTypeInt, MPI_COMM_WORLD);
+    if (stat != MPI_SUCCESS) ENZO_FAIL("");
+#else
     stat = MPI_Alltoall(NumberToMove, SendCount, DataTypeInt,
 			RecvListCount, RecvCount, DataTypeInt, MPI_COMM_WORLD);
     if (stat != MPI_SUCCESS) ENZO_FAIL("");
+#endif //End of USE_SLUG
 
     /* Allocate buffers and generated displacement list. */
 
+#ifdef USE_SLUG
+    NumberOfReceives = 0;  
+    int NumberOfReceives2 = 0;  
+    for (i = 0; i < NumberOfProcessors; i++) {
+      MPI_RecvListDisplacements[i] = NumberOfReceives2;
+      NumberOfReceives += RecvListCount[i];
+      NumberOfReceives2 += RecvListCount2[i];
+      MPI_RecvListCount[i] = RecvListCount2[i];
+    }
+#else
     NumberOfReceives = 0;  
     for (i = 0; i < NumberOfProcessors; i++) {
       MPI_RecvListDisplacements[i] = NumberOfReceives;
       NumberOfReceives += RecvListCount[i];
       MPI_RecvListCount[i] = RecvListCount[i];
     }
+#endif //End of USE_SLUG
 
     SharedList = new particle_data[NumberOfReceives];
+#ifdef USE_SLUG
+    char *SharedBuffer = NULL;
+    SharedBuffer = new char[NumberOfReceives*(sizeof(particle_data)+sizeof(size_t)+MaxBufferSizeParticleObject)];
+#endif //End of USE_SLUG
  
     /******************************
           Share the particles
     ******************************/
 
+#ifdef USE_SLUG
+    char *SendBuffer = NULL;
+    SendBuffer = new char[NumberOfSends*(sizeof(particle_data)+sizeof(size_t)+MaxBufferSizeParticleObject)];
+    k = 0;
+    l = 0;
+    m = 0;
+    TotalBufferSizeSoFar = 0;
+    for (i = 0; i < NumberOfProcessors; i++) {
+      for (j = 0; j < SendListCount[i]; j++){
+        ((particle_data *)(SendBuffer + TotalBufferSizeSoFar))[0] = SendList[k];
+        TotalBufferSizeSoFar += sizeof(particle_data);
+        k++;
+      }
+      size_t sizes[SendListCount[i]];
+      for (j = 0; j < SendListCount[i]; j++){
+        if (SendList[l].object != NULL) {
+          ((size_t *)(SendBuffer + TotalBufferSizeSoFar))[0] = static_cast<particle_slug_object *>(SendList[l].object)->buffer_size();
+          sizes[j] = ((size_t *)(SendBuffer + TotalBufferSizeSoFar))[0];
+          if (sizes[j] > MaxBufferSizeParticleObject)
+            printf("Warning: a buffer size of slug_cluster exceeds MaxBufferSizeParticleObject. The size = %d\n", sizes[j]);
+        }
+        else {
+          ((size_t *)(SendBuffer + TotalBufferSizeSoFar))[0] = 0;
+          sizes[j] = ((size_t *)(SendBuffer + TotalBufferSizeSoFar))[0];
+        }
+        TotalBufferSizeSoFar += sizeof(size_t);
+        l++;
+      }
+      for (j = 0; j < SendListCount[i]; j++){
+        if (SendList[m].object != NULL) {
+          static_cast<particle_slug_object *>(SendList[m].object)->pack_buffer(SendBuffer + TotalBufferSizeSoFar);
+          delete SendList[m].object;
+          SendList[m].object = NULL;
+        }
+        TotalBufferSizeSoFar += sizes[j];
+        m++;
+      }
+    }
+#endif //End of USE_SLUG
+
+#ifdef USE_SLUG
+    stat = MPI_Alltoallv(SendBuffer, MPI_SendListCount, MPI_SendListDisplacements,
+			   MPI_BYTE,
+			 SharedBuffer, MPI_RecvListCount, MPI_RecvListDisplacements,
+			   MPI_BYTE,
+			 MPI_COMM_WORLD);
+#else
     stat = MPI_Alltoallv(SendList, MPI_SendListCount, MPI_SendListDisplacements,
 			   MPI_ParticleMoveList,
 			 SharedList, MPI_RecvListCount, MPI_RecvListDisplacements,
 			   MPI_ParticleMoveList,
 			 MPI_COMM_WORLD);
+#endif //End of USE_SLUG
     if (stat != MPI_SUCCESS) ENZO_FAIL("");
 
+#ifdef USE_SLUG
+    k = 0;
+    l = 0;
+    TotalBufferSizeSoFar = 0;
+    for (i = 0; i < NumberOfProcessors; i++) {
+      for (j = 0; j < RecvListCount[i]; j++) {
+        SharedList[k] = ((particle_data *)(SharedBuffer + TotalBufferSizeSoFar))[0];
+        TotalBufferSizeSoFar += sizeof(particle_data);
+        k++;
+      }
+      size_t sizes[RecvListCount[i]];
+      for (j = 0; j < RecvListCount[i]; j++) {
+        sizes[j] = ((size_t *)(SharedBuffer + TotalBufferSizeSoFar))[0];
+        TotalBufferSizeSoFar += sizeof(size_t);
+      }
+      for (j = 0; j < RecvListCount[i]; j++) {
+        if (sizes[j] != 0) {
+          SharedList[l].object = static_cast<particle_object *>(new particle_slug_object);
+          static_cast<particle_slug_object *>(SharedList[l].object)->reconstruct_cluster(SharedBuffer + TotalBufferSizeSoFar);
+        }
+        TotalBufferSizeSoFar += sizes[j];
+        l++;
+      }
+    }
+#endif //End of USE_SLUG
+
 #ifdef MPI_INSTRUMENTATION
     endtime = MPI_Wtime();
     timer[9] += endtime-starttime;
     delete [] MPI_RecvListCount;
     delete [] MPI_RecvListDisplacements;
 
+#ifdef USE_SLUG
+    delete [] SendListCount;
+    delete [] SendListCount2;
+    delete [] RecvListCount2;
+    delete [] SendBuffer;
+    SendBuffer = NULL;
+    delete [] SharedBuffer;
+    SharedBuffer = NULL;
+#endif //End of USE_SLUG
+
 #endif /* USE_MPI */    
 
   } // ENDIF multi-processor
File src/enzo/ExtractSection.C MODIFIED
Side-by-side diff  View file   More
   float *Mass;
   PINT  *Number;
   int   *Type;
+#ifdef USE_SLUG
+  particle_object **Object;
+#endif //End of USE_SLUG
  
   Mass = new float[RHC];
   Number = new PINT[RHC];
   {
     Attribute[i] = new float[RHC];
   }
- 
+
+#ifdef USE_SLUG
+  Object = new particle_object*[RHC];
+#endif //End of USE_SLUG
+
 //
  
   int RHP = 0; // global counter
   Temp = LevelArray[0];
  
   while (Temp != NULL) {
+#ifdef USE_SLUG
+    if (Grids[ExtractLevel]->MoveSubgridParticles(Temp->GridData,
+                                                  &RHP,
+                                                  Number,
+                                                  Type,
+                                                  Mass,
+                                                  Position,
+                                                  Velocity,
+                                                  Attribute,
+                                                  Object) == FAIL)
+#else
     if (Grids[ExtractLevel]->MoveSubgridParticles(Temp->GridData,
                                                   &RHP,
                                                   Number,
                                                   Position,
                                                   Velocity,
                                                   Attribute) == FAIL)
+#endif //End of USE_SLUG
     {
       fprintf(stderr, "Error in grid->MoveSubgridParticles.\n");
       my_exit(EXIT_FAILURE);
   }
  
 //  RHP = RHP - 1;
+#ifdef USE_SLUG
+  Grids[ExtractLevel]->SetParticlePointers(Mass, Number, Type, Position, Velocity, Attribute, Object);
+#else
   Grids[ExtractLevel]->SetParticlePointers(Mass, Number, Type, Position, Velocity, Attribute);
+#endif //End of USE_SLUG
   Grids[ExtractLevel]->SetNumberOfParticles(RHP);
  
 /*
File src/enzo/FOF_allvars.h MODIFIED
Side-by-side diff  View file   More
 #ifndef __FOF_ALLVARS_H
 #define __FOF_ALLVARS_H
 
+#ifdef USE_SLUG
+#include "particle_object.h"
+#endif //End of USE_SLUG
+
 /************************************************************************
   CONSTANTS
 ************************************************************************/
   Eint32    	GrLen;
   float  	Mass;
   float  	Attr[MAX_NUMBER_OF_PARTICLE_ATTRIBUTES];
+#ifdef USE_SLUG
+  particle_object *Object;
+#endif //End of USE_SLUG
   float  	Energy;
   float  	Rho;
   PINT    	PartID;
File src/enzo/Grid.h MODIFIED
Side-by-side diff  View file   More
 ************************************************************************/
 #ifndef GRID_DEFINED__
 #define GRID_DEFINED__
+#ifdef USE_SLUG
+#include "particle_object.h"
+#endif //End of USE_SLUG
 #include "ProtoSubgrid.h"
 #include "ListOfParticles.h"
 #include "region.h"
   PINT  *ParticleNumber;                   // unique identifier
   int   *ParticleType;                     // type of particle
   float *ParticleAttribute[MAX_NUMBER_OF_PARTICLE_ATTRIBUTES];
+#ifdef USE_SLUG
+  particle_object **ParticleObject;
+#endif //End of USE_SLUG
 
 //
 //  Star particle data
 //   int MoveSubgridParticles(grid *TargetGrid);
 
 
+#ifdef USE_SLUG
+   int MoveSubgridParticles(grid *TargetGrid,
+                            int *Counter,
+                            PINT *Number,
+                            int *Type,
+                            float *Mass,
+                            FLOAT *Position[],
+                            float *Velocity[],
+                            float *Attribute[],
+                            particle_object **Object);
+#else
    int MoveSubgridParticles(grid *TargetGrid,
                             int *Counter,
                             PINT *Number,
                             FLOAT *Position[],
                             float *Velocity[],
                             float *Attribute[]);
+#endif //End of USE_SLUG
 
 
 /* Particles: same as above, but a version that is much more efficient. */
        if (ParticleAttribute[i] != NULL) delete [] ParticleAttribute[i];
        ParticleAttribute[i] = NULL;
      }   
+#ifdef USE_SLUG
+     if (ParticleObject != NULL) delete [] ParticleObject;
+     ParticleObject = NULL;
+#endif //End of USE_SLUG
    };
 
 /* Particles: allocate new particle fields. */
      }
      for (int i = 0; i < NumberOfParticleAttributes; i++)
        ParticleAttribute[i] = new float[NumberOfNewParticles];
+#ifdef USE_SLUG
+     ParticleObject = new particle_object*[NumberOfNewParticles];
+     for (int i = 0; i < NumberOfNewParticles; i++)
+       ParticleObject[i] = NULL;
+#endif //End of USE_SLUG
    };
 
 /* Particles: Copy pointers passed into into grid. */
 
+#ifdef USE_SLUG
+   void SetParticlePointers(float *Mass, PINT *Number, int *Type,
+                            FLOAT *Position[], 
+			    float *Velocity[], float *Attribute[],
+                            particle_object **Object) {
+#else
    void SetParticlePointers(float *Mass, PINT *Number, int *Type,
                             FLOAT *Position[], 
 			    float *Velocity[], float *Attribute[]) {
+#endif //End of USE_SLUG
     ParticleMass   = Mass;
     ParticleNumber = Number;
     ParticleType   = Type;
     }
     for (int i = 0; i < NumberOfParticleAttributes; i++)
       ParticleAttribute[i] = Attribute[i];
+#ifdef USE_SLUG
+    ParticleObject = Object;
+#endif //End of USE_SLUG
    };
 
 /* Particles: Set new star particle index. */
   int CreateChildParticles(float dx, int NumberOfParticles, float *ParticleMass,
 			   int *ParticleType, FLOAT *ParticlePosition[],
 			   float *ParticleVelocity[], float *ParticleAttribute[],
+#ifdef USE_SLUG
+                           particle_object **ParticleObject,
+#endif //End of USE_SLUG
 			   FLOAT *CellLeftEdge[], int *GridDimension, 
 			   int MaximumNumberOfNewParticles, int *NumberOfNewParticles);
 
File src/enzo/Grid_AddOneParticleFromList.C MODIFIED
Side-by-side diff  View file   More
   float *Velocity[MAX_DIMENSION];
   float *Mass;
   float *Attribute[MAX_NUMBER_OF_PARTICLE_ATTRIBUTES];
+#ifdef USE_SLUG
+  particle_object **Object;
+#endif //End of USE_SLUG
 
   Number = new PINT[NumberOfParticles];
   Type = new int[NumberOfParticles];
   }
   for (i = 0; i < NumberOfParticleAttributes; i++)
     Attribute[i] = new float[NumberOfParticles];
+#ifdef USE_SLUG
+  Object = new particle_object*[NumberOfParticles];
+#endif //End of USE_SLUG
 
   /* copy old particles to their new home. */
 
     }
     for (n = 0; n < NumberOfParticleAttributes; n++)
       Attribute[n][i] = ParticleAttribute[n][i];
+#ifdef USE_SLUG
+    Object[i]   = ParticleObject[i];
+#endif //End of USE_SLUG
   
   }
 
   }
   for (n = 0; n < NumberOfParticleAttributes; n++)
     Attribute[n][i] = List[place].Attribute[n];
+#ifdef USE_ SLUG
+  Object[i] = List[place].Object;
+#endif
 
   /* Delete FromGrid's particles (now copied). */
 
   
   /* Copy new pointers into their correct position. */
   
+#ifdef USE_SLUG
+  this->SetParticlePointers(Mass, Number, Type, Position, Velocity, 
+			    Attribute, Object);
+#else
   this->SetParticlePointers(Mass, Number, Type, Position, Velocity, 
 			    Attribute);
+#endif //End of USE_SLUG
 
   return SUCCESS;
 }
File src/enzo/Grid_AddParticlesFromList.C MODIFIED
Side-by-side diff  View file   More
   float *Velocity[MAX_DIMENSION];
   float *Mass;
   float *Attribute[MAX_NUMBER_OF_PARTICLE_ATTRIBUTES];
+#ifdef USE_SLUG
+  particle_object **Object;
+#endif //End of USE_SLUG
 
   Number = new PINT[NumberOfParticles];
   Type = new int[NumberOfParticles];
   }
   for (int i = 0; i < NumberOfParticleAttributes; i++)
     Attribute[i] = new float[NumberOfParticles];
+#ifdef USE_SLUG
+  Object = new particle_object*[NumberOfParticles];
+#endif //End of USE_SLUG
 
   /* copy old particles to their new home. */
 
     }
     for (int n = 0; n < NumberOfParticleAttributes; n++)
       Attribute[n][i] = ParticleAttribute[n][i];
+#ifdef USE_SLUG
+    Object[i]   = ParticleObject[i];
+#endif //End of USE_SLUG
   
   }
 
     }
     for (int n = 0; n < NumberOfParticleAttributes; n++)
       Attribute[n][i] = List[NewIndex[j]].Attribute[n];
+#ifdef USE_SLUG
+    Object[i] = List[NewIndex[j]].Object;
+#endif //End of USE_SLUG
   }
 
   /* Delete FromGrid's particles (now copied). */
   
   /* Copy new pointers into their correct position. */
   
+#ifdef USE_SLUG
+  this->SetParticlePointers(Mass, Number, Type, Position, Velocity, 
+			    Attribute, Object);
+#else
   this->SetParticlePointers(Mass, Number, Type, Position, Velocity, 
 			    Attribute);
+#endif //End of USE_SLUG
 
   delete [] NewIndex;
 
File src/enzo/Grid_CleanUpMovedParticles.C MODIFIED
Side-by-side diff  View file   More
   FLOAT *Position[MAX_DIMENSION];
   float *Velocity[MAX_DIMENSION], *Mass,
         *Attribute[MAX_NUMBER_OF_PARTICLE_ATTRIBUTES];
+#ifdef USE_SLUG
+  particle_object **Object;
+#endif //End of USE_SLUG
  
   /* Count the number of unmoved particles. */
  
     }
     for (i = 0; i < NumberOfParticleAttributes; i++)
       Attribute[i] = new float[NumberOfParticlesRemaining];
+#ifdef USE_SLUG
+    Object = new particle_object*[NumberOfParticlesRemaining];
+#endif //End of USE_SLUG
  
     /* Copy unmoved particles to their new home. */
  
 	}
 	for (n = 0; n < NumberOfParticleAttributes; n++)
 	  Attribute[n][j] = ParticleAttribute[n][i];
+#ifdef USE_SLUG
+	Object[j] = ParticleObject[i];
+#endif //End of USE_SLUG
  
 	j++;   // increment moved particle counter
  
  
     /* Copy new pointers into their correct position. */
  
+#ifdef USE_SLUG
+    this->SetParticlePointers(Mass, Number, Type, Position, Velocity,
+			      Attribute, Object);
+#else
     this->SetParticlePointers(Mass, Number, Type, Position, Velocity,
 			      Attribute);
+#endif //End of USE_SLUG
  
   }
  
File src/enzo/Grid_CollectParticles.C MODIFIED
Side-by-side diff  View file   More
       List[n1].type = ParticleType[i];
       for (j = 0; j < NumberOfParticleAttributes; j++)
 	List[n1].attribute[j] = ParticleAttribute[j][i];
+#ifdef USE_SLUG
+      List[n1].object = ParticleObject[i];
+#endif //End of USE_SLUG
       List[n1].grid = GridNum;
       List[n1].proc = ProcessorNumber;
       //ParticleMass[i] = FLOAT_UNDEFINED;
           *Attribute[MAX_NUMBER_OF_PARTICLE_ATTRIBUTES];
     int *Type;
     PINT *Number;
+#ifdef USE_SLUG
+    particle_object **Object;
+#endif //End of USE_SLUG
  
     if (TotalNumberOfParticles > 0) {
 
       }
       for (i = 0; i < NumberOfParticleAttributes; i++)
 	Attribute[i] = new float[TotalNumberOfParticles];
+#ifdef USE_SLUG
+      Object = new particle_object*[TotalNumberOfParticles];
+#endif //End of USE_SLUG
 
       if (Velocity[GridRank-1] == NULL && TotalNumberOfParticles != 0) {
 	ENZO_FAIL("malloc error (out of memory?)\n");
 	Mass[i] = ParticleMass[i];
 	Number[i] = ParticleNumber[i];
 	Type[i] = ParticleType[i];
+#ifdef USE_SLUG
+	Object[i] = ParticleObject[i];
+#endif //End of USE_SLUG
       }
 
       for (dim = 0; dim < GridRank; dim++)
 	Mass[n] = List[i].mass;
 	Number[n] = List[i].id;
 	Type[n] = List[i].type;
+#ifdef USE_SLUG
+	Object[n] = List[i].object;
+#endif //End of USE_SLUG
 	n++;
       }
 
  
     this->DeleteParticles();
     if (TotalNumberOfParticles > 0)
+#ifdef USE_SLUG
+      this->SetParticlePointers(Mass, Number, Type, Position, Velocity,
+				Attribute, Object);
+#else
       this->SetParticlePointers(Mass, Number, Type, Position, Velocity,
 				Attribute);
+#endif //End of USE_SLUG
  
   } // end: if (COPY_IN)
 
File src/enzo/Grid_CommunicationSendParticles.C MODIFIED
Side-by-side diff  View file   More
 #include <stdlib.h>
 #include <stdio.h>
 #include <math.h>
- 
+
+#ifdef USE_SLUG
+#include "particle_slug_object.h"
+#endif //End of USE_SLUG
+
 #include "ErrorExceptions.h"
 #include "macros_and_parameters.h"
 #include "typedefs.h"
 {
 #ifdef USE_MPI 
   int i, j, dim, index;
+#ifdef USE_SLUG
+  size_t extended_buffer_size;
+#endif //End of USE_SLUG
 
   if (CommunicationShouldExit(ProcessorNumber, ToProcessor))
     return SUCCESS;
   /* Allocate buffer. */
  
   particle_data *buffer = NULL;
+#ifdef USE_SLUG
+  char *extended_buffer = NULL;
+  if (CommunicationDirection == COMMUNICATION_RECEIVE) {
+    extended_buffer = (char *) CommunicationReceiveBuffer[CommunicationReceiveIndex];
+    buffer = (particle_data *) CommunicationReceiveBuffer[CommunicationReceiveIndex];
+  }
+  else {
+    extended_buffer = new char[TransferSize*(sizeof(particle_data) + sizeof(size_t) + MaxBufferSizeParticleObject)];
+    buffer = (particle_data *) extended_buffer;
+  }
+#else
   if (CommunicationDirection == COMMUNICATION_RECEIVE)
-    buffer = (particle_data*) CommunicationReceiveBuffer[CommunicationReceiveIndex];
+    buffer = (particle_data *) CommunicationReceiveBuffer[CommunicationReceiveIndex];
   else
-    buffer = new particle_data[TransferSize];
+    buffer = new particle_data[TransferSize]; 
+#endif //End of USE_SLUG
  
   /* If this is the from processor, pack fields. */
  
       buffer[index].mass = ParticleMass[i];
       buffer[index].id = ParticleNumber[i];
       buffer[index].type = ParticleType[i];
+#ifdef USE_SLUG
+      buffer[index].object = NULL;
+#endif //End of USE_SLUG
     } // ENDFOR particles
 
     for (j = 0; j < NumberOfParticleAttributes; j++) {
       for (i = FromStart; i < FromEnd; i++, index++)
 	buffer[index].attribute[j] = ParticleAttribute[j][i];
     }
+
+#ifdef USE_SLUG
+    size_t *sizes = (size_t *)(buffer + TransferSize); 
+    index = 0;
+    for (i = FromStart; i < FromEnd; i++, index++) {
+      if (ParticleObject[i] != NULL) {
+        sizes[index] = static_cast<particle_slug_object *>(ParticleObject[i])->buffer_size();
+        if (sizes[index] > MaxBufferSizeParticleObject)
+          printf("Warning: a buffer size of slug_cluster exceeds MaxBufferSizeParticleObject. The size = %d\n", sizes[index]);
+      }
+      else
+        sizes[index] = 0;
+    }
+    extended_buffer_size = TransferSize * (sizeof(particle_data) + sizeof(size_t)); 
+    char *object_ptr = (char *)(sizes + TransferSize); 
+    index = 0;
+    for (i = FromStart; i < FromEnd; i++, index++) {
+      if (ParticleObject[i] != NULL) {
+        static_cast<particle_slug_object *>(ParticleObject[i])->pack_buffer(object_ptr); 
+        delete ParticleObject[i];
+        ParticleObject[i] = NULL;
+      }
+      object_ptr += sizes[index]; 
+      extended_buffer_size += sizes[index];
+    } 
+#endif //End of USE_SLUG
  
   } // end: if (MyProcessorNumber)
  
   FLOAT *TempPos[MAX_DIMENSION];
   float  *TempVel[MAX_DIMENSION], *TempMass,
         *TempAttribute[MAX_NUMBER_OF_PARTICLE_ATTRIBUTES];
+#ifdef USE_SLUG
+  particle_object **TempObject;
+#endif //End of USE_SLUG
   PINT *TempNumber;
   int NewNumber = FromNumber, *TempType;
   if (ToStart == -1)
       }
       for (j = 0; j < NumberOfParticleAttributes; j++)
 	TempAttribute[j] = ToGrid->ParticleAttribute[j];
+#ifdef USE_SLUG
+      TempObject = ToGrid->ParticleObject;
+#endif //End of USE_SLUG
       ToGrid->ParticleNumber = NULL;  // signal that we should reallocate
     }
  
 	ToGrid->ParticleNumber[i] = TempNumber[i];
 	ToGrid->ParticleMass[i]   = TempMass[i];
 	ToGrid->ParticleType[i]   = TempType[i];
+#ifdef USE_SLUG
+	ToGrid->ParticleObject[i]   = TempObject[i];
+#endif //End of USE_SLUG
       }
       for (dim = 0; dim < GridRank; dim++)
 	for (i = 0; i < ToGrid->NumberOfParticles; i++) {
       }
       for (j = 0; j < NumberOfParticleAttributes; j++)
 	delete [] TempAttribute[j];
+#ifdef USE_SLUG
+      delete [] TempObject;
+#endif //End of USE_SLUG
       ToStart = ToGrid->NumberOfParticles;
     }
  
 #endif
 
     if (MyProcessorNumber == ProcessorNumber)
+#ifdef USE_SLUG
+      CommunicationBufferedSend(extended_buffer, extended_buffer_size, MPI_BYTE,
+				Dest, MPI_SENDPART_TAG, MPI_COMM_WORLD,
+				BUFFER_IN_PLACE);
+#else
       CommunicationBufferedSend(buffer, Count, ParticleDataType,
 				Dest, MPI_SENDPART_TAG, MPI_COMM_WORLD,
 				BUFFER_IN_PLACE);
+#endif //End of USE_SLUG
 
     if (MyProcessorNumber == ToProcessor) {
 
+#ifdef USE_SLUG
+      extended_buffer_size = TransferSize * (sizeof(particle_data) + sizeof(size_t) + MaxBufferSizeParticleObject);
+#endif //End of USE_SLUG
+
       if (CommunicationDirection == COMMUNICATION_POST_RECEIVE) {
+#ifdef USE_SLUG
+	MPI_Irecv(extended_buffer, extended_buffer_size, MPI_BYTE, Source,
+		  MPI_SENDPART_TAG, MPI_COMM_WORLD,
+		  CommunicationReceiveMPI_Request+CommunicationReceiveIndex);
+#else
 	MPI_Irecv(buffer, Count, ParticleDataType, Source,
 		  MPI_SENDPART_TAG, MPI_COMM_WORLD,
 		  CommunicationReceiveMPI_Request+CommunicationReceiveIndex);
+#endif //End of USE_SLUG
 
 //	printf("Posting receive from P%"ISYM" for %"ISYM" particles in "
 //	       "comm index %"ISYM"\n", Source, TransferSize, 
 	CommunicationReceiveArgumentInt[1][CommunicationReceiveIndex] = FromNumber;
 	CommunicationReceiveArgumentInt[2][CommunicationReceiveIndex] = ToStart;
 
+#ifdef USE_SLUG
+	CommunicationReceiveBuffer[CommunicationReceiveIndex] = (float *) extended_buffer;
+#else
 	CommunicationReceiveBuffer[CommunicationReceiveIndex] = (float *) buffer;
+#endif //End of USE_SLUG
 	CommunicationReceiveDependsOn[CommunicationReceiveIndex] = 
 	  CommunicationReceiveCurrentDependsOn;
 	CommunicationReceiveIndex++;
+
       }
 
       if (CommunicationDirection == COMMUNICATION_SEND_RECEIVE)
+#ifdef USE_SLUG
+	MPI_Recv(extended_buffer, extended_buffer_size, MPI_BYTE, Source,
+		 MPI_SENDPART_TAG, MPI_COMM_WORLD, &status);
+#else
 	MPI_Recv(buffer, Count, ParticleDataType, Source,
 		 MPI_SENDPART_TAG, MPI_COMM_WORLD, &status);
+#endif //End of USE_SLUG
 
     } // ENDIF (MyProcessorNumber == ToProcessor)
  
 	ToGrid->ParticleAttribute[j][i] = buffer[index].attribute[j];
     }
 
+#ifdef USE_SLUG
+    size_t *sizes = (size_t *)(buffer + TransferSize); 
+    char *object_ptr = (char *)(sizes + TransferSize); 
+    index = 0; 
+    for (i = ToStart; i < ToEnd; i++, index++) { 
+      if (sizes[index] != 0){
+        ToGrid->ParticleObject[i] = static_cast<particle_object *>(new particle_slug_object);
+        static_cast<particle_slug_object *>(ToGrid->ParticleObject[i])->reconstruct_cluster(object_ptr);
+        object_ptr += sizes[index];
+      }
+      else
+        object_ptr += sizes[index];
+    }
+#endif //End of USE_SLUG
+
     /* Only delete the buffer if we're in receive mode (in send mode
        it will be deleted by CommunicationBufferedSend and if we're in
        post-receive mode then it will be deleted when we get to
        receive-mode). */
 
+#ifdef USE_SLUG
+    delete [] extended_buffer;
+    extended_buffer = NULL;
+#else
     delete [] buffer;
+#endif //End of USE_SLUG
     			
   } // end: if (MyProcessorNumber...)
 
File src/enzo/Grid_CommunicationTransferParticlesOpt.C MODIFIED
Side-by-side diff  View file   More
 	  List[n1].type = ParticleType[i];
 	  for (j = 0; j < NumberOfParticleAttributes; j++)
 	    List[n1].attribute[j] = ParticleAttribute[j][i];
+#ifdef USE_SLUG
+	  List[n1].object = ParticleObject[i];
+#endif //End of USE_SLUG
 	  List[n1].grid = grid;
 	  List[n1].proc = MyProcessorNumber;
 	  ParticleMass[i] = FLOAT_UNDEFINED;
     FLOAT *Position[MAX_DIMENSION];
     float *Velocity[MAX_DIMENSION], *Mass,
       *Attribute[MAX_NUMBER_OF_PARTICLE_ATTRIBUTES];
+#ifdef USE_SLUG
+    particle_object **Object;
+#endif //End of USE_SLUG
     PINT *Number;
     int *Type;
 
       }
       for (i = 0; i < NumberOfParticleAttributes; i++)
 	Attribute[i] = new float[TotalNumberOfParticles];
+#ifdef USE_SLUG
+      Object = new particle_object*[TotalNumberOfParticles];
+#endif //End of USE_SLUG
 
       if (Velocity[GridRank-1] == NULL && TotalNumberOfParticles != 0) {
 	ENZO_FAIL("malloc error (out of memory?)\n");
 	  Mass[n] = ParticleMass[i];
 	  Number[n] = ParticleNumber[i];
 	  Type[n] = ParticleType[i];
+#ifdef USE_SLUG
+	  Object[n] = ParticleObject[i];
+#endif //End of USE_SLUG
 	  n++;
 	}
 
 	Type[n] = List[i].type;
 	for (j = 0; j < NumberOfParticleAttributes; j++)
 	  Attribute[j][n] = List[i].attribute[j];
+#ifdef USE_SLUG
+	Object[n] = List[i].object;
+#endif //End of USE_SLUG
       
 	n++;
 
  
     this->DeleteParticles();
     if (NumberOfParticles > 0)
+#ifdef USE_SLUG
+      this->SetParticlePointers(Mass, Number, Type, Position, Velocity,
+				Attribute, Object);
+#else
       this->SetParticlePointers(Mass, Number, Type, Position, Velocity,
 				Attribute);
+#endif //End of USE_SLUG
  
 #ifdef USE_MPI
     t01 = MPI_Wtime();
File src/enzo/Grid_CreateChildParticles.C MODIFIED
Side-by-side diff  View file   More
 int grid::CreateChildParticles(float dx, int NumberOfParticles, float *ParticleMass,
 			       int *ParticleType, FLOAT *ParticlePosition[],
 			       float *ParticleVelocity[], float *ParticleAttribute[],
+#ifdef USE_SLUG
+                               particle_object **ParticleObject,
+#endif //End of USE_SLUG
 			       FLOAT *CellLeftEdge[], int *GridDimension, 
 			       int MaximumNumberOfNewParticles, int *NumberOfNewParticles)
 			 
 	      this->ParticleType[child] = ParticleType[partnum];
 	      for(i = 0; i < NumberOfParticleAttributes; i++)
 		this->ParticleAttribute[i][child] = ParticleAttribute[i][numpart];
+#ifdef USE_SLUG
+              this->ParticleObject[child] = ParticleObject[partnum];
+#endif //End of USE_SLUG
 	    }
 
 	  /* Loop forward by CHILDRENPERPARENT each time. */
File src/enzo/Grid_MoveAllParticles.C MODIFIED
Side-by-side diff  View file   More
   FLOAT *Position[MAX_DIMENSION];
   float *Velocity[MAX_DIMENSION], *Mass,
         *Attribute[MAX_NUMBER_OF_PARTICLE_ATTRIBUTES];
+#ifdef USE_SLUG
+  particle_object **Object;
+#endif //End of USE_SLUG
  
   Mass = new float[TotalNumberOfParticles];
   Number = new PINT[TotalNumberOfParticles];
   }
   for (int i = 0; i < NumberOfParticleAttributes; i++)
     Attribute[i] = new float[TotalNumberOfParticles];
+#ifdef USE_SLUG
+  Object = new particle_object*[TotalNumberOfParticles];
+#endif //End of USE_SLUG
   
   if (Velocity[GridRank-1] == NULL) {
     ENZO_FAIL("malloc error (out of memory?)\n");
     Mass[i]   = ParticleMass[i];
     Number[i] = ParticleNumber[i];
     Type[i]   = ParticleType[i];
+#ifdef USE_SLUG
+    Object[i]   = ParticleObject[i];
+#endif //End of USE_SLUG
   }
   for (dim = 0; dim < GridRank; dim++)
     for (i = 0; i < NumberOfParticles; i++) {
  
   /* Copy new pointers into their correct position. */
  
+#ifdef USE_SLUG
+  this->SetParticlePointers(Mass, Number, Type, Position, Velocity,
+			    Attribute, Object);
+#else
   this->SetParticlePointers(Mass, Number, Type, Position, Velocity,
 			    Attribute);
+#endif //End of USE_SLUG
  
   /* Copy FromGrids' particles to new space on local "fake" grid. */
  
       Mass[Index+i] = FromGrid[grid]->ParticleMass[i] * MassDecrease;
       Number[Index+i] = FromGrid[grid]->ParticleNumber[i];
       Type[Index+i] = FromGrid[grid]->ParticleType[i];
+#ifdef USE_SLUG
+      Object[Index+i] = FromGrid[grid]->ParticleObject[i];
+#endif //End of USE_SLUG
     }
     
     for (dim = 0; dim < GridRank; dim++)
   FLOAT *Position[MAX_DIMENSION];
   float *Velocity[MAX_DIMENSION], *Mass,
         *Attribute[MAX_NUMBER_OF_PARTICLE_ATTRIBUTES];
+#ifdef USE_SLUG
+  particle_object **Object;
+#endif //End of USE_SLUG
 
   if (MyProcessorNumber == ProcessorNumber) {
      Mass = new float[TotalNumberOfParticles];
      }
      for (int i = 0; i < NumberOfParticleAttributes; i++)
        Attribute[i] = new float[TotalNumberOfParticles];
+#ifdef USE_SLUG
+     Object = new particle_object*[TotalNumberOfParticles];
+#endif //End of USE_SLUG
 
      if (Velocity[GridRank-1] == NULL) {
        fprintf(stderr, "malloc error (out of memory?)\n");
        Mass[i]   = ParticleMass[i];
        Number[i] = ParticleNumber[i];
        Type[i]   = ParticleType[i];
+#ifdef USE_SLUG
+       Object[i]   = ParticleObject[i];
+#endif //End of USE_SLUG
      }
      for (dim = 0; dim < GridRank; dim++)
        for (i = 0; i < NumberOfParticles; i++) {
 
     /* Copy new pointers into their correct position. */
 
+#ifdef USE_SLUG
+    this->SetParticlePointers(Mass, Number, Type, Position, Velocity,  
+			      Attribute, Object);
+#else
     this->SetParticlePointers(Mass, Number, Type, Position, Velocity,  
 			      Attribute);
+#endif //End of USE_SLUG
   }
 
   /* Copy FromGrids' particles to new space (starting at NumberOfParticles). */
 	Mass[Index+i] = FromGrid[grid]->ParticleMass[i] * MassDecrease;
 	Number[Index+i] = FromGrid[grid]->ParticleNumber[i];
 	Type[Index+i] = FromGrid[grid]->ParticleType[i];
+#ifdef USE_SLUG
+	Object[Index+i] = FromGrid[grid]->ParticleObject[i];
+#endif //End of USE_SLUG
       }
 
       for (dim = 0; dim < GridRank; dim++)
File src/enzo/Grid_MoveParticlesFOF.C MODIFIED
Side-by-side diff  View file   More
       P[Index].Energy = 0.0;
       P[Index].Rho = 0.0;
 
+#ifdef USE_SLUG
+      P[Index].Object = ParticleObject[i];
+#endif //End of USE_SLUG
     }
 
     this->DeleteParticles();
 	ParticleMass[i] = P[i].Mass * MassConvInv;
 	ParticleType[i] = P[i].Type;
 	ParticleNumber[i] = P[i].PartID;
+#ifdef USE_SLUG
+	ParticleObject[i] = P[i].Object;
+#endif //End of USE_SLUG
       }
 
     NumberOfParticles = npart;
File src/enzo/Grid_MoveSubgridParticles.C MODIFIED
Side-by-side diff  View file   More
 #include "ExternalBoundary.h"
 #include "Grid.h"
  
+#ifdef USE_SLUG
+int grid::MoveSubgridParticles(grid* FromGrid,
+                               int *Counter,
+                               PINT *X_Number,
+                               int *X_Type,
+                               float *X_Mass,
+                               FLOAT *X_Position[],
+                               float *X_Velocity[],
+                               float *X_Attribute[],
+                               particle_object **X_Object)
+#else
 int grid::MoveSubgridParticles(grid* FromGrid,
                                int *Counter,
                                PINT *X_Number,
                                FLOAT *X_Position[],
                                float *X_Velocity[],
                                float *X_Attribute[])
+#endif //End of USE_SLUG
 {
  
 int start;
       for (k = 0; k < NumberOfParticleAttributes; k++) {
         X_Attribute[k][start] = FromGrid->ParticleAttribute[k][i];
       }
+
+#ifdef USE_SLUG
+      X_Object[start] = FromGrid->ParticleObject[i];
+#endif //End of USE_SLUG
  
       j++;   // increment moved particle counter
       start++;
File src/enzo/Grid_MoveSubgridParticlesFast.C MODIFIED
Side-by-side diff  View file   More
         }
 	for (j = 0; j < NumberOfParticleAttributes; j++)
 	  ToGrids[subgrid]->ParticleAttribute[j][n] = ParticleAttribute[j][i];
+#ifdef USE_SLUG
+	ToGrids[subgrid]->ParticleObject[n] = ParticleObject[i];
+#endif //End of USE_SLUG
  
 	ToGrids[subgrid]->NumberOfParticles++;
  
File src/enzo/Grid_ReturnParticleEntry.C MODIFIED
Side-by-side diff  View file   More
     }
     for (int n = 0; n < NumberOfParticleAttributes; n++) 
       List->Attribute[n] = ParticleAttribute[n][i];
+#ifdef USE_SLUG
+    List->Object = ParticleObject[i];
+#endif //End of USE_SLUG
     List++;
   }
 
File src/enzo/Grid_SortParticlesByNumber.C MODIFIED
Side-by-side diff  View file   More
  
 /* function prototypes */
  
+#ifdef USE_SLUG
+void QuickSortAndDrag(PINT List[], int left, int right,
+		      int NumberToDrag1, float *DragList1[],
+		      int NumberToDrag2, FLOAT *DragList2[],
+		      int NumberToDrag3, int   *DragList3[],
+                      int NumberToDrag4, particle_object **DragList4[]);
+#else
 void QuickSortAndDrag(PINT List[], int left, int right,
 		      int NumberToDrag1, float *DragList1[],
 		      int NumberToDrag2, FLOAT *DragList2[],
 		      int NumberToDrag3, int   *DragList3[]);
+#endif //End of USE_SLUG
  
  
 void grid::SortParticlesByNumber()
   float **DragList1 = new float*[GridRank+1+NumberOfParticleAttributes];
   FLOAT **DragList2 = new FLOAT*[GridRank];
   int   **DragList3 = new int*[1];
+#ifdef USE_SLUG
+  particle_object ***DragList4 = new particle_object**[1];
+#endif //End of USE_SLUG
   for (dim = 0; dim < GridRank; dim++) {
     DragList2[dim] = ParticlePosition[dim];
     DragList1[dim] = ParticleVelocity[dim];
   DragList3[0]        = ParticleType;
   for (j = 0; j < NumberOfParticleAttributes; j++)
     DragList1[GridRank+1+j] = ParticleAttribute[j];
+#ifdef USE_SLUG
+  DragList4[0]        = ParticleObject;
+#endif //End of USE_SLUG
  
   /* Sort by particle index, dragging the data along. */
  
+#ifdef USE_SLUG
+  QuickSortAndDrag(ParticleNumber, 0, NumberOfParticles-1,
+		   GridRank+1+NumberOfParticleAttributes, DragList1,
+		   GridRank, DragList2, 1, DragList3, 1, DragList4);
+#else
   QuickSortAndDrag(ParticleNumber, 0, NumberOfParticles-1,
 		   GridRank+1+NumberOfParticleAttributes, DragList1,
 		   GridRank, DragList2, 1, DragList3);
+#endif //End of USE_SLUG
  
   /* Clean up. */
  
   delete [] DragList1;
   delete [] DragList2;
   delete [] DragList3;
+#ifdef USE_SLUG
+  delete [] DragList4;
+#endif //End of USE_SLUG
  
   return;
 }
File src/enzo/Grid_SortParticlesByType.C MODIFIED
Side-by-side diff  View file   More
  
 /* function prototypes */
  
+#ifdef USE_SLUG
+void ShellSortAndDrag(int List[], int N,
+		      int NumberToDrag1, float *DragList1[],
+		      int NumberToDrag2, FLOAT *DragList2[],
+		      int NumberToDrag3, PINT  *DragList3[],
+                      int NumberToDrag4, particle_object **DragList4[]);
+#else
 void ShellSortAndDrag(int List[], int N,
 		      int NumberToDrag1, float *DragList1[],
 		      int NumberToDrag2, FLOAT *DragList2[],
 		      int NumberToDrag3, PINT  *DragList3[]);
+#endif //End of USE_SLUG
  
  
 void grid::SortParticlesByType()
   float **DragList1 = new float*[GridRank+1+NumberOfParticleAttributes];
   FLOAT **DragList2 = new FLOAT*[GridRank];
   PINT   **DragList3 = new PINT*[1];
+#ifdef USE_SLUG
+  particle_object ***DragList4 = new particle_object**[1];
+#endif //End of USE_SLUG
   for (dim = 0; dim < GridRank; dim++) {
     DragList2[dim] = ParticlePosition[dim];
     DragList1[dim] = ParticleVelocity[dim];
   DragList3[0]        = ParticleNumber;
   for (j = 0; j < NumberOfParticleAttributes; j++)
     DragList1[GridRank+1+j] = ParticleAttribute[j];
+#ifdef USE_SLUG
+  DragList4[0]        = ParticleObject;
+#endif //End of USE_SLUG
  
   /* Sort by particle index, dragging the data along. */
  
+#ifdef USE_SLUG
+  ShellSortAndDrag(ParticleType, NumberOfParticles,
+		   GridRank+1+NumberOfParticleAttributes, DragList1,
+		   GridRank, DragList2, 1, DragList3, 1, DragList4);
+#else
   ShellSortAndDrag(ParticleType, NumberOfParticles,
 		   GridRank+1+NumberOfParticleAttributes, DragList1,
 		   GridRank, DragList2, 1, DragList3);
+#endif //End of USE_SLUG
  
   /* Clean up. */
  
   delete [] DragList1;
   delete [] DragList2;
   delete [] DragList3;
+#ifdef USE_SLUG
+  delete [] DragList4;
+#endif //ENd of USE_SLUG
  
   return;
 }
File src/enzo/Grid_TracerParticleCreateParticles.C MODIFIED
Side-by-side diff  View file   More
       *TempAttribute[MAX_NUMBER_OF_PARTICLE_ATTRIBUTES];
     PINT *TempNumber;
     int  *TempType;
+#ifdef USE_SLUG
+    particle_object **TempObject;
+#endif //End of USE_SLUG
  
     // initialize temporary quantities
     TempMass = ParticleMass;
     TempNumber = ParticleNumber;
     TempType = ParticleType;
+#ifdef USE_SLUG
+    TempObject = ParticleObject;
+#endif //End of USE_SLUG
  
     for (dim = 0; dim < GridRank; dim++) {
       TempPos[dim] = ParticlePosition[dim];
       ParticleMass[i]   = TempMass[i];
       ParticleNumber[i] = TempNumber[i];
       ParticleType[i]   = TempType[i];
+#ifdef USE_SLUG
+      ParticleObject[i]   = TempObject[i];
+#endif //End of USE_SLUG
     }
 
     for (dim = 0; dim < GridRank; dim++)
     delete [] TempMass;
     delete [] TempNumber;
     delete [] TempType;
+#ifdef USE_SLUG
+    delete [] TempObject;
+#endif //End of USE_SLUG
 
     for (dim = 0; dim < GridRank; dim++) {
       delete [] TempPos[dim];
File src/enzo/Grid_TransferSubgridParticles.C MODIFIED
Side-by-side diff  View file   More
 	  List[n1].type = ParticleType[i];
 	  for (j = 0; j < NumberOfParticleAttributes; j++)
 	    List[n1].attribute[j] = ParticleAttribute[j][i];
+#ifdef USE_SLUG
+	  List[n1].object = ParticleObject[i];
+#endif //End of USE_SLUG
 	  List[n1].grid = subgrid[i];
 	  List[n1].proc = proc;
 	  ParticleMass[i] = FLOAT_UNDEFINED;
           *Attribute[MAX_NUMBER_OF_PARTICLE_ATTRIBUTES];
     PINT *Number;
     int  *Type;
+#ifdef USE_SLUG
+    particle_object **Object;
+#endif //End of USE_SLUG
  
     if (TotalNumberOfParticles > 0) {
 
     }
     for (i = 0; i < NumberOfParticleAttributes; i++)
       Attribute[i] = new float[TotalNumberOfParticles];
+#ifdef USE_SLUG
+    Object = new particle_object*[TotalNumberOfParticles];
+#endif //End of USE_SLUG
 
     if (Velocity[GridRank-1] == NULL && TotalNumberOfParticles != 0) {
       fprintf(stderr, "malloc error (out of memory?)\n");
       Mass[i] = ParticleMass[i];
       Number[i] = ParticleNumber[i];
       Type[i] = ParticleType[i];
+#ifdef USE_SLUG
+      Object[i] = ParticleObject[i];
+#endif //End of USE_SLUG
     }
 
     for (dim = 0; dim < GridRank; dim++)
       Mass[n] = List[i].mass;
       Number[n] = List[i].id;
       Type[n] = List[i].type;
+#ifdef USE_SLUG
+      Object[n] = List[i].object;
+#endif //End of USE_SLUG
       n++;
     }
 
  
     this->DeleteParticles();
     if (TotalNumberOfParticles > 0)
+#ifdef USE_SLUG
+      this->SetParticlePointers(Mass, Number, Type, Position, Velocity,
+				Attribute, Object);
+#else
       this->SetParticlePointers(Mass, Number, Type, Position, Velocity,
 				Attribute);
+#endif //End of USE_SLUG
  
   } // end: if (COPY_IN)
 
File src/enzo/Grid_constructor.C MODIFIED
Side-by-side diff  View file   More
   GravityBoundaryType           = GravityUndefined;
   for (i = 0; i < MAX_NUMBER_OF_PARTICLE_ATTRIBUTES; i++)
     ParticleAttribute[i] = NULL;
+#ifdef USE_SLUG
+  ParticleObject                = NULL;
+#endif //End of USE_SLUG
 
   BoundaryFluxes                = NULL;
  
File src/enzo/Grid_destructor.C MODIFIED
Side-by-side diff  View file   More
  
   for (i = 0; i < MAX_NUMBER_OF_PARTICLE_ATTRIBUTES; i++)
     delete [] ParticleAttribute[i];
+#ifdef USE_SLUG
+  delete [] ParticleObject;
+#endif //End of USE_SLUG
 
   delete divB;
   for (int i=0; i<3; i++) {
File src/enzo/Make.config.assemble MODIFIED
Side-by-side diff  View file   More
 	$(error Illegal value '$(CONFIG_GRACKLE)' for $$(CONFIG_GRACKLE))
     endif
 
+#-----------------------------------------------------------------------
+# DETERMINE USE SLUG
+#-----------------------------------------------------------------------
+
+    ERROR_SLUG = 1
+
+    # compilers and settings if SLUG is yes
+
+    ifeq ($(CONFIG_SLUG),yes)
+        ERROR_SLUG = 0
+        ASSEMBLE_SLUG_DEFINES     = -DUSE_SLUG
+        ASSEMBLE_SLUG_INCLUDES    = $(MACH_INCLUDES_SLUG)
+        ASSEMBLE_SLUG_LIBS        = $(MACH_LIBS_SLUG)
+    endif
+
+    # compilers and settings if SLUG is no
+
+    ifeq ($(CONFIG_SLUG),no)
+        ERROR_SLUG = 0
+        ASSEMBLE_SLUG_DEFINES =
+    endif
+
+    # error if CONFIG_SLUG is incorrect
+
+    ifeq ($(ERROR_SLUG),1)
+       .PHONY: error_compilers
+       error_compilers:
+	$(error Illegal value '$(CONFIG_SLUG)' for $$(CONFIG_SLUG))
+    endif
+
 
 #-----------------------------------------------------------------------
 # DETERMINE LOG2ALLOC SETTINGS
               $(ASSEMBLE_GRAVITY_4S_DEFINES) \
               $(ASSEMBLE_ENZO_PERFORMANCE_DEFINES) \
               $(ASSEMBLE_GRACKLE_DEFINES) \
+              $(ASSEMBLE_SLUG_DEFINES) \
               $(ASSEMBLE_LOG2ALLOC_DEFINES) \
               $(ASSEMBLE_ACCELERATION_BOUNDARY_DEFINES)
 
                $(ASSEMBLE_NEW_PROBLEM_TYPES_INCLUDES) \
                $(ASSEMBLE_PAPI_INCLUDES) \
                $(ASSEMBLE_GRACKLE_INCLUDES) \
+               $(ASSEMBLE_SLUG_INCLUDES) \
                $(MAKEFILE_INCLUDES)   -I.
 
     OBJS_LIB = $(OBJS_CONFIG_LIB) \
            $(ASSEMBLE_PYTHON_LIBS) \
            $(ASSEMBLE_NEW_PROBLEM_TYPES_LIBS) \
            $(ASSEMBLE_CUDA_LIBS) \
-           $(ASSEMBLE_GRACKLE_LIBS)
+           $(ASSEMBLE_GRACKLE_LIBS) \
+           $(ASSEMBLE_SLUG_LIBS)
 
 
File src/enzo/Make.config.objects MODIFIED
Side-by-side diff  View file   More
 	OutputPotentialFieldOnly.o \
 	OutputSmoothedDarkMatterOnly.o \
         P_ColumnFormat.o \
+        particle_slug_object.o \
 	ParticleMergeRoutines.o \
         ParticleSplitter.o \
 	performance.o \
File src/enzo/Make.config.settings MODIFIED
Side-by-side diff  View file   More
 #    CONFIG_SET_ACCELERATION_BOUNDARY
 #    CONFIG_ENZO_PERFORMANCE
 #    CONFIG_GRACKLE
+#    CONFIG_SLUG
 #
 #=======================================================================
 
      CONFIG_GRACKLE = no
 
 #======================================================================= 
+# CONFIG_SLUG
+#======================================================================= 
+#    yes           Compile with Slug support
+#    no            Compile without Slug support
+#----------------------------------------------------------------------- 
+ 
+     CONFIG_SLUG = no
+
+#======================================================================= 
 # CONFIG_LOG2ALLOC
 #======================================================================= 
 #    yes           Compile with power of 2 block size allocations
File src/enzo/Make.config.targets MODIFIED
Side-by-side diff  View file   More
 	@echo "      gmake grackle-yes"
 	@echo "      gmake grackle-no"
 	@echo
+	@echo "   Set whether to compile with support for the Slug"
+	@echo
+	@echo "      gmake slug-yes"
+	@echo "      gmake slug-no"
+	@echo
 	@echo "   Set whether to compile with grid/particle arrays allocated in sizes of powers of 2"
 	@echo
 	@echo "      gmake log2alloc-yes"
 	@echo "   CONFIG_GRAVITY_4S  [gravity-4s-{yes,no}]                  : $(CONFIG_GRAVITY_4S)"
 	@echo "   CONFIG_ENZO_PERFORMANCE  [enzo-performance-{yes,no}]      : $(CONFIG_ENZO_PERFORMANCE)"
 	@echo "   CONFIG_GRACKLE  [grackle-{yes,no}]                        : $(CONFIG_GRACKLE)"
+	@echo "   CONFIG_SLUG  [slug-{yes,no}]                              : $(CONFIG_SLUG)"
 	@echo "   CONFIG_LOG2ALLOC  [log2alloc-{yes,no}]                    : $(CONFIG_LOG2ALLOC)"
 	@echo
 
 
 #-----------------------------------------------------------------------
 
+VALID_SLUG = slug-yes slug-no
+.PHONY: $(VALID_SLUG)
+
+slug-yes: CONFIG_SLUG-yes
+slug-no: CONFIG_SLUG-no
+slug-%:
+	@printf "\n\tInvalid target: $@\n\n\tValid targets: [$(VALID_SLUG)]\n\n"
+CONFIG_SLUG-%: suggest-clean
+	@tmp=.config.temp; \
+        grep -v CONFIG_SLUG $(MAKE_CONFIG_OVERRIDE) > $${tmp}; \
+        mv $${tmp} $(MAKE_CONFIG_OVERRIDE); \
+        echo "CONFIG_SLUG = $*" >> $(MAKE_CONFIG_OVERRIDE); \
+	$(MAKE)  show-config | grep CONFIG_SLUG; \
+	echo
+
+#-----------------------------------------------------------------------
+
 VALID_LOG2ALLOC = log2alloc-yes log2alloc-no
 .PHONY: $(VALID_LOG2ALLOC)
 
File src/enzo/New_Grid_ReadGrid.C MODIFIED
Side-by-side diff  View file   More
 #include <assert.h>
 #include "h5utilities.h"
  
+#ifdef USE_SLUG
+#include "particle_slug_object.h"
+#endif //End of USE_SLUG
 #include "ErrorExceptions.h"
 #include "macros_and_parameters.h"
 #include "typedefs.h"
     }
     } // ENDELSE add particle attributes
  
+#ifdef USE_SLUG
+    /* Read ParticleObject, which is saved as a serialised buffer. */
+    hsize_t TempIntArrayParticleObject[1];
+    int NumberOfObjects = 0;
+    for (i = 0; i < NumberOfParticles; i++)
+      if (ParticleType[i] == 2 || ParticleType[i] == 4) NumberOfObjects++;
+    TempIntArrayParticleObject[0] = NumberOfParticles * sizeof(size_t) + NumberOfObjects * MaxBufferSizeParticleObject;
+    char *BufferParticleObject = NULL;
+    BufferParticleObject = new char[TempIntArrayParticleObject[0]];
+    this->read_dataset(1, TempIntArrayParticleObject, "particle_object",
+                       group_id, H5T_NATIVE_CHAR, (VOIDP) BufferParticleObject,
+                       FALSE);
+    int TotalBufferSizeSoFar = 0;
+    size_t sizes[NumberOfParticles];
+    for (int i = 0; i < NumberOfParticles; i++) {
+      sizes[i] = ((size_t *)(BufferParticleObject + TotalBufferSizeSoFar))[0];
+      TotalBufferSizeSoFar += sizeof(size_t);
+    }
+    for (int i = 0; i < NumberOfParticles; i++) {
+      if (sizes[i] != 0) {
+        ParticleObject[i] = static_cast<particle_object *>(new particle_slug_object);
+        static_cast<particle_slug_object *>(ParticleObject[i])->reconstruct_cluster(BufferParticleObject + TotalBufferSizeSoFar);
+      }
+      TotalBufferSizeSoFar += sizes[i];
+    }
+    delete [] BufferParticleObject;
+    BufferParticleObject = NULL;
+#endif //End of USE_SLUG
+
+
     delete [] temp;
  
 
File src/enzo/New_Grid_WriteGrid.C MODIFIED
Side-by-side diff  View file   More
 #include <assert.h>
 #include "h5utilities.h"
  
+#ifdef USE_SLUG
+#include "particle_slug_object.h"
+#endif //End of USE_SLUG
 #include "ErrorExceptions.h"
 #include "macros_and_parameters.h"
 #include "typedefs.h"
           group_id, HDF5_REAL, (VOIDP) ParticleAttribute[j], FALSE);
     }
 
+#ifdef USE_SLUG
+    /* Write particle object as a serialised buffer. */
+    hsize_t TempIntArrayParticleObject[1];
+    char *BufferParticleObject = NULL;
+    BufferParticleObject = new char[NumberOfParticles*(sizeof(size_t) + MaxBufferSizeParticleObject)];
+    int TotalBufferSizeSoFar = 0;
+    size_t sizes[NumberOfParticles];
+    for (int i = 0; i < NumberOfParticles; i++) {
+      if (ParticleObject[i] != NULL) {
+        ((size_t *)(BufferParticleObject + TotalBufferSizeSoFar))[0] = static_cast<particle_slug_object *>(ParticleObject[i])->buffer_size();
+        sizes[i] = ((size_t *)(BufferParticleObject + TotalBufferSizeSoFar))[0];
+        if (sizes[i] > MaxBufferSizeParticleObject)
+          printf("Warning: a buffer size of slug_cluster exceeds MaxBufferSizeParticleObject. The size = %d\n", sizes[i]);
+      }
+      else {
+        ((size_t *)(BufferParticleObject + TotalBufferSizeSoFar))[0] = 0;
+        sizes[i] = 0;
+      }
+      TotalBufferSizeSoFar += sizeof(size_t);
+    }
+    for (int i = 0; i < NumberOfParticles; i++) {
+      if (ParticleObject[i] != NULL)
+        static_cast<particle_slug_object *>(ParticleObject[i])->pack_buffer(BufferParticleObject + TotalBufferSizeSoFar);
+      TotalBufferSizeSoFar += sizes[i];
+    }
+    TempIntArrayParticleObject[0] = TotalBufferSizeSoFar;
+    this->write_dataset(1, TempIntArrayParticleObject, "particle_object",
+        group_id, H5T_NATIVE_CHAR, (VOIDP) BufferParticleObject, FALSE);
+    delete [] BufferParticleObject;
+    BufferParticleObject = NULL;
+#endif //End if USE_SLUG
+
     /* clean up */
 
     delete [] temp;
File src/enzo/QuickSortAndDrag.C MODIFIED
Side-by-side diff  View file   More
 #include <stdio.h>
 #include "ErrorExceptions.h"
 #include "macros_and_parameters.h"
+#ifdef USE_SLUG
+#include "particle_object.h"
+#endif //End of USE_SLUG
  
 #define SWAP(A, n1, n2, tmp) {tmp = A[n1]; A[n1] = A[n2]; A[n2] = tmp;}
 
 // List = 32-bit int, DragList3 = 32-bit int
  
+#ifdef USE_SLUG
+void QuickSortAndDrag(Eint32 List[], int left, int right,
+		      int NumberToDrag1, float *DragList1[],
+		      int NumberToDrag2, FLOAT *DragList2[],
+		      int NumberToDrag3, Eint32 *DragList3[],
+                      int NumberToDrag4, particle_object **DragList4[])
+#else
 void QuickSortAndDrag(Eint32 List[], int left, int right,
 		      int NumberToDrag1, float *DragList1[],
 		      int NumberToDrag2, FLOAT *DragList2[],
 		      int NumberToDrag3, Eint32 *DragList3[])
+#endif //End of USE_SLUG
 {
  
   int i, n, last, leftright2;
   Eint32 temp1;
   float temp2;
   FLOAT temp3;
+#ifdef USE_SLUG
+  particle_object *temp4;
+#endif //End of USE_SLUG
  
   if (left >= right)
     return;
     SWAP(DragList2[n], left, leftright2, temp3)
   for (n = 0; n < NumberToDrag3; n++)
     SWAP(DragList3[n], left, leftright2, temp1)
+#ifdef USE_SLUG
+  for (n = 0; n < NumberToDrag4; n++)
+    SWAP(DragList4[n], left, leftright2, temp4)
+#endif //End of USE_SLUG
  
   last = left;
  
 	SWAP(DragList2[n], last, i, temp3)
       for (n = 0; n < NumberToDrag3; n++)
 	SWAP(DragList3[n], last, i, temp1)
+#ifdef USE_SLUG
+      for (n = 0; n < NumberToDrag4; n++)
+	SWAP(DragList4[n], last, i, temp4)
+#endif //End of USE_SLUG
     }
  
   SWAP(List, left, last, temp1)
     SWAP(DragList2[n], left, last, temp3)
   for (n = 0; n < NumberToDrag3; n++)
     SWAP(DragList3[n], left, last, temp1)
+#ifdef USE_SLUG
+  for (n = 0; n < NumberToDrag4; n++)
+    SWAP(DragList4[n], left, last, temp4)
+#endif //End of USE_SLUG
  
+#ifdef USE_SLUG
+  QuickSortAndDrag(List, left  , last-1,
+		   NumberToDrag1, DragList1, NumberToDrag2, DragList2,
+		   NumberToDrag3, DragList3, NumberToDrag4, DragList4);
+  QuickSortAndDrag(List, last+1, right ,
+		   NumberToDrag1, DragList1, NumberToDrag2, DragList2,
+		   NumberToDrag3, DragList3, NumberToDrag4, DragList4);
+#else
   QuickSortAndDrag(List, left  , last-1,
 		   NumberToDrag1, DragList1, NumberToDrag2, DragList2,
 		   NumberToDrag3, DragList3);
   QuickSortAndDrag(List, last+1, right ,
 		   NumberToDrag1, DragList1, NumberToDrag2, DragList2,
 		   NumberToDrag3, DragList3);
+#endif //End of USE_SLUG
  
 }
 
 //----------------------------------------------------------------------
 // List = 64-bit int, DragList3 = 32-bit int
  
+#ifdef USE_SLUG
+void QuickSortAndDrag(Eint64 List[], int left, int right,
+		      int NumberToDrag1, float *DragList1[],
+		      int NumberToDrag2, FLOAT *DragList2[],
+		      int NumberToDrag3, Eint32 *DragList3[],
+                      int NumberToDrag4, particle_object **DragList4[])
+#else
 void QuickSortAndDrag(Eint64 List[], int left, int right,
 		      int NumberToDrag1, float *DragList1[],
 		      int NumberToDrag2, FLOAT *DragList2[],
 		      int NumberToDrag3, Eint32 *DragList3[])
+#endif //End of USE_SLUG
 {
  
   int i, n, last, leftright2;
   Eint64 temp1_64;
   float temp2;
   FLOAT temp3;
+#ifdef USE_SLUG
+  particle_object *temp4;
+#endif //End of USE_SLUG
  
   if (left >= right)
     return;
     SWAP(DragList2[n], left, leftright2, temp3)
   for (n = 0; n < NumberToDrag3; n++)
     SWAP(DragList3[n], left, leftright2, temp1_32)
+#ifdef USE_SLUG
+  for (n = 0; n < NumberToDrag4; n++)
+    SWAP(DragList4[n], left, leftright2, temp4)
+#endif //End of USE_SLUG
  
   last = left;
  
 	SWAP(DragList2[n], last, i, temp3)
       for (n = 0; n < NumberToDrag3; n++)
 	SWAP(DragList3[n], last, i, temp1_32)
+#ifdef USE_SLUG
+      for (n = 0; n < NumberToDrag4; n++)
+	SWAP(DragList4[n], last, i, temp4)
+#endif //End of USE_SLUG
     }
  
   SWAP(List, left, last, temp1_64)
     SWAP(DragList2[n], left, last, temp3)
   for (n = 0; n < NumberToDrag3; n++)
     SWAP(DragList3[n], left, last, temp1_32)
+#ifdef USE_SLUG
+  for (n = 0; n < NumberToDrag4; n++)
+    SWAP(DragList4[n], left, last, temp4)
+#endif //End of USE_SLUG
  
+#ifdef USE_SLUG
+  QuickSortAndDrag(List, left  , last-1,
+		   NumberToDrag1, DragList1, NumberToDrag2, DragList2,
+		   NumberToDrag3, DragList3, NumberToDrag4, DragList4);
+  QuickSortAndDrag(List, last+1, right ,
+		   NumberToDrag1, DragList1, NumberToDrag2, DragList2,
+		   NumberToDrag3, DragList3, NumberToDrag4, DragList4);
+#else
   QuickSortAndDrag(List, left  , last-1,
 		   NumberToDrag1, DragList1, NumberToDrag2, DragList2,
 		   NumberToDrag3, DragList3);
   QuickSortAndDrag(List, last+1, right ,
 		   NumberToDrag1, DragList1, NumberToDrag2, DragList2,
 		   NumberToDrag3, DragList3);
+#endif //End of USE_SLUG
  
 }
 
 //----------------------------------------------------------------------
 // List = 32-bit int, DragList3 = 64-bit int
 
+#ifdef USE_SLUG
+void QuickSortAndDrag(Eint32 List[], int left, int right,
+		      int NumberToDrag1, float *DragList1[],
+		      int NumberToDrag2, FLOAT *DragList2[],
+		      int NumberToDrag3, Eint64 *DragList3[],
+                      int NumberToDrag4, particle_object **DragList4[])
+#else
 void QuickSortAndDrag(Eint32 List[], int left, int right,
 		      int NumberToDrag1, float *DragList1[],
 		      int NumberToDrag2, FLOAT *DragList2[],
 		      int NumberToDrag3, Eint64 *DragList3[])
+#endif //End of USE_SLUG
 {
  
   int i, n, last, leftright2;
   Eint64 temp1_64;
   float temp2;
   FLOAT temp3;
+#ifdef USE_SLUG
+  particle_object *temp4;
+#endif //End of USE_SLUG
  
   if (left >= right)
     return;
     SWAP(DragList2[n], left, leftright2, temp3)
   for (n = 0; n < NumberToDrag3; n++)
     SWAP(DragList3[n], left, leftright2, temp1_64)
+#ifdef USE_SLUG
+  for (n = 0; n < NumberToDrag4; n++)
+    SWAP(DragList4[n], left, leftright2, temp4)
+#endif //End of USE_SLUG
  
   last = left;
  
 	SWAP(DragList2[n], last, i, temp3)
       for (n = 0; n < NumberToDrag3; n++)
 	SWAP(DragList3[n], last, i, temp1_64)
+#ifdef USE_SLUG
+      for (n = 0; n < NumberToDrag4; n++)
+	SWAP(DragList4[n], last, i, temp4)
+#endif //End of USE_SLUG
     }
  
   SWAP(List, left, last, temp1_32)
     SWAP(DragList2[n], left, last, temp3)
   for (n = 0; n < NumberToDrag3; n++)
     SWAP(DragList3[n], left, last, temp1_64)
+#ifdef USE_SLUG
+  for (n = 0; n < NumberToDrag4; n++)
+    SWAP(DragList4[n], left, last, temp4)
+#endif //End of USE_SLUG
  
+#ifdef USE_SLUG
+  QuickSortAndDrag(List, left  , last-1,
+		   NumberToDrag1, DragList1, NumberToDrag2, DragList2,
+		   NumberToDrag3, DragList3, NumberToDrag4, DragList4);
+  QuickSortAndDrag(List, last+1, right ,
+		   NumberToDrag1, DragList1, NumberToDrag2, DragList2,
+		   NumberToDrag3, DragList3, NumberToDrag4, DragList4);
+#else
   QuickSortAndDrag(List, left  , last-1,
 		   NumberToDrag1, DragList1, NumberToDrag2, DragList2,
 		   NumberToDrag3, DragList3);
   QuickSortAndDrag(List, last+1, right ,
 		   NumberToDrag1, DragList1, NumberToDrag2, DragList2,
 		   NumberToDrag3, DragList3);
+#endif //End of USE_SLUG
  
 }
 
 //----------------------------------------------------------------------
 // List = 64-bit int, DragList3 = 64-bit int
 
+#ifdef USE_SLUG
+void QuickSortAndDrag(Eint64 List[], int left, int right,
+		      int NumberToDrag1, float *DragList1[],
+		      int NumberToDrag2, FLOAT *DragList2[],
+		      int NumberToDrag3, Eint64 *DragList3[],
+                      int NumberToDrag4, particle_object **DragList4[])
+#else
 void QuickSortAndDrag(Eint64 List[], int left, int right,
 		      int NumberToDrag1, float *DragList1[],
 		      int NumberToDrag2, FLOAT *DragList2[],
 		      int NumberToDrag3, Eint64 *DragList3[])
+#endif //End of USE_SLUG
 {
  
   int i, n, last, leftright2;
   Eint64 temp1;
   float temp2;
   FLOAT temp3;
+#ifdef USE_SLUG
+  particle_object *temp4;
+#endif //End of USE_SLUG
  
   if (left >= right)
     return;
     SWAP(DragList2[n], left, leftright2, temp3)
   for (n = 0; n < NumberToDrag3; n++)
     SWAP(DragList3[n], left, leftright2, temp1)
+#ifdef USE_SLUG
+  for (n = 0; n < NumberToDrag4; n++)
+    SWAP(DragList4[n], left, leftright2, temp4)
+#endif //End of USE_SLUG
  
   last = left;
  
 	SWAP(DragList2[n], last, i, temp3)
       for (n = 0; n < NumberToDrag3; n++)
 	SWAP(DragList3[n], last, i, temp1)
+#ifdef USE_SLUG
+      for (n = 0; n < NumberToDrag4; n++)
+	SWAP(DragList4[n], last, i, temp4)
+#endif //End of USE_SLUG
     }
  
   SWAP(List, left, last, temp1)
     SWAP(DragList2[n], left, last, temp3)
   for (n = 0; n < NumberToDrag3; n++)
     SWAP(DragList3[n], left, last, temp1)
+#ifdef USE_SLUG
+  for (n = 0; n < NumberToDrag4; n++)
+    SWAP(DragList4[n], left, last, temp4)
+#endif //End of USE_SLUG
  
+#ifdef USE_SLUG
+  QuickSortAndDrag(List, left  , last-1,
+		   NumberToDrag1, DragList1, NumberToDrag2, DragList2,
+		   NumberToDrag3, DragList3, NumberToDrag4, DragList4);
+  QuickSortAndDrag(List, last+1, right ,
+		   NumberToDrag1, DragList1, NumberToDrag2, DragList2,
+		   NumberToDrag3, DragList3, NumberToDrag4, DragList4);
+#else
   QuickSortAndDrag(List, left  , last-1,
 		   NumberToDrag1, DragList1, NumberToDrag2, DragList2,
 		   NumberToDrag3, DragList3);
   QuickSortAndDrag(List, last+1, right ,
 		   NumberToDrag1, DragList1, NumberToDrag2, DragList2,
 		   NumberToDrag3, DragList3);
+#endif //End of USE_SLUG
  
 }
  
File src/enzo/ReadParameterFile.C MODIFIED
Side-by-side diff  View file   More
     ret += sscanf(line, "NumberOfParticleAttributes = %"ISYM,
 		  &NumberOfParticleAttributes);
 
+    /* Particle object handling */
+    #ifdef USE_SLUG
+    ret += sscanf(line, "MaxBufferSizeParticleObject = %"ISYM,
+		  &MaxBufferSizeParticleObject);
+    #endif
+
     /* read data which defines the boundary conditions */
  
     ret += sscanf(line, "LeftFaceBoundaryCondition  = %"ISYM" %"ISYM" %"ISYM,
File src/enzo/SetDefaultGlobalValues.C MODIFIED
Side-by-side diff  View file   More
   WriteGhostZones                  = FALSE;
   OutputParticleTypeGrouping       = FALSE;
 
+  /* Particle object handling */
+  #ifdef USE_SLUG
+  MaxBufferSizeParticleObject = 100000;
+  #endif
+
   IsotropicConduction = FALSE;
   AnisotropicConduction = FALSE;
   IsotropicConductionSpitzerFraction = 0.0;
File src/enzo/ShellSortAndDrag.C MODIFIED
Side-by-side diff  View file   More
 
 // List = 32-bit int, DragList3 = 32-bit int
  
+#ifdef USE_SLUG
+void ShellSortAndDrag(Eint32 List[], int N,
+		      int NumberToDrag1, float *DragList1[],
+		      int NumberToDrag2, FLOAT *DragList2[],
+		      int NumberToDrag3, Eint32 *DragList3[],
+                      int NumberToDrag4, particle_object **DragList4[])
+#else
 void ShellSortAndDrag(Eint32 List[], int N,
 		      int NumberToDrag1, float *DragList1[],
 		      int NumberToDrag2, FLOAT *DragList2[],
 		      int NumberToDrag3, Eint32 *DragList3[])
+#endif //End of USE_SLUG
 {
 
   int a, nn, i, j, m;
   Eint32 temp1, t11, t12[NumberToDrag3];
   float temp2, t2[NumberToDrag1];
   FLOAT temp3, t3[NumberToDrag2];
+#ifdef USE_SLUG
+  particle_object *temp4, *t4[NumberToDrag4];
+#endif //End of USE_SLUG
 
   m = N;
   for (nn = 1; nn <= N; nn <<= 1) {
 	t3[a] = DragList2[a][j];
       for (a = 0; a < NumberToDrag3; a++)
 	t12[a] = DragList3[a][j];
+#ifdef USE_SLUG
+      for (a = 0; a < NumberToDrag4; a++)
+	t4[a] = DragList4[a][j];
+#endif //End of USE_SLUG
 
       while (i >= 0 && List[i] > t11) {
 //	printf("P%d: i=%d, j=%d, m=%d, Swapping %d (type=%d) and %d (type=%d)\n",
 	  SWAP(DragList2[a], i+m, i, temp3)
 	for (a = 0; a < NumberToDrag3; a++)
 	  SWAP(DragList3[a], i+m, i, temp1)
+#ifdef USE_SLUG
+	for (a = 0; a < NumberToDrag4; a++)
+	  SWAP(DragList4[a], i+m, i, temp4)
+#endif //End of USE_SLUG
 	i -= m;
       }
 
 	DragList2[a][i+m] = t3[a];
       for (a = 0; a < NumberToDrag3; a++)
 	DragList3[a][i+m] = t12[a];
+#ifdef USE_SLUG
+      for (a = 0; a < NumberToDrag4; a++)
+	DragList4[a][i+m] = t4[a];
+#endif //End of USE_SLUG
 
     } // ENDFOR j
   } // ENDFOR nn
 //----------------------------------------------------------------------
 // List = 64-bit int, DragList3 = 32-bit int
  
+#ifdef USE_SLUG
+void ShellSortAndDrag(Eint64 List[], int N,
+		      int NumberToDrag1, float *DragList1[],
+		      int NumberToDrag2, FLOAT *DragList2[],
+		      int NumberToDrag3, Eint32 *DragList3[],
+                      int NumberToDrag4, particle_object **DragList4[])
+#else
 void ShellSortAndDrag(Eint64 List[], int N,
 		      int NumberToDrag1, float *DragList1[],
 		      int NumberToDrag2, FLOAT *DragList2[],
 		      int NumberToDrag3, Eint32 *DragList3[])
+#endif //End of USE_SLUG
 {
  
   int a, nn, i, j, m;
   Eint64 temp1_64, t11;
   float temp2, t2[NumberToDrag1];
   FLOAT temp3, t3[NumberToDrag2];
+#ifdef USE_SLUG
+  particle_object *temp4, *t4[NumberToDrag4];
+#endif //End of USE_SLUG
 
   m = N;
   for (nn = 1; nn <= N; nn <<= 1) {
 	t3[a] = DragList2[a][j];
       for (a = 0; a < NumberToDrag3; a++)
 	t12[a] = DragList3[a][j];
+#ifdef USE_SLUG
+      for (a = 0; a < NumberToDrag4; a++)
+	t4[a] = DragList4[a][j];
+#endif //End of USE_SLUG
 
       while (i >= 0 && List[i] > t11) {
 	SWAP(List, i+m, i, temp1_64);
 	  SWAP(DragList2[a], i+m, i, temp3);
 	for (a = 0; a < NumberToDrag3; a++)
 	  SWAP(DragList3[a], i+m, i, temp1_32);
+#ifdef USE_SLUG
+	for (a = 0; a < NumberToDrag4; a++)
+	  SWAP(DragList4[a], i+m, i, temp4);
+#endif //End of USE_SLUG
 	i -= m;
       }
 
 	DragList2[a][i+m] = t3[a];
       for (a = 0; a < NumberToDrag3; a++)
 	DragList3[a][i+m] = t12[a];
+#ifdef USE_SLUG
+      for (a = 0; a < NumberToDrag4; a++)
+	DragList4[a][i+m] = t4[a];
+#endif //End of USE_SLUG
 
     } // ENDFOR j
   } // ENDFOR nn
 //----------------------------------------------------------------------
 // List = 32-bit int, DragList3 = 64-bit int
 
+#ifdef USE_SLUG
+void ShellSortAndDrag(Eint32 List[], int N,
+		      int NumberToDrag1, float *DragList1[],
+		      int NumberToDrag2, FLOAT *DragList2[],
+		      int NumberToDrag3, Eint64 *DragList3[],
+                      int NumberToDrag4, particle_object **DragList4[])
+#else
 void ShellSortAndDrag(Eint32 List[], int N,
 		      int NumberToDrag1, float *DragList1[],
 		      int NumberToDrag2, FLOAT *DragList2[],
 		      int NumberToDrag3, Eint64 *DragList3[])
+#endif //End of USE_SLUG
 {
  
   int a, nn, i, j, m;
   Eint64 temp1_64, t12[NumberToDrag3];
   float temp2, t2[NumberToDrag1];
   FLOAT temp3, t3[NumberToDrag2];
+#ifdef USE_SLUG
+  particle_object *temp4, *t4[NumberToDrag4];
+#endif //End of USE_SLUG
 
   m = N;
   for (nn = 1; nn <= N; nn <<= 1) {
 	t3[a] = DragList2[a][j];
       for (a = 0; a < NumberToDrag3; a++)
 	t12[a] = DragList3[a][j];
+#ifdef USE_SLUG
+      for (a = 0; a < NumberToDrag4; a++)
+	t4[a] = DragList4[a][j];
+#endif //End of USE_SLUG
 
       while (i >= 0 && List[i] > t11) {
 	SWAP(List, i+m, i, temp1_32);
 	  SWAP(DragList2[a], i+m, i, temp3);
 	for (a = 0; a < NumberToDrag3; a++)
 	  SWAP(DragList3[a], i+m, i, temp1_64);
+#ifdef USE_SLUG
+	for (a = 0; a < NumberToDrag4; a++)
+	  SWAP(DragList4[a], i+m, i, temp4);
+#endif //End of USE_SLUG
 	i -= m;
       }
 
 	DragList2[a][i+m] = t3[a];
       for (a = 0; a < NumberToDrag3; a++)
 	DragList3[a][i+m] = t12[a];
+#ifdef USE_SLUG
+      for (a = 0; a < NumberToDrag4; a++)
+	DragList4[a][i+m] = t4[a];
+#endif //End of USE_SLUG
 
     } // ENDFOR j
   } // ENDFOR nn
 //----------------------------------------------------------------------
 // List = 64-bit int, DragList3 = 64-bit int
 
+#ifdef USE_SLUG
+void ShellSortAndDrag(Eint64 List[], int N,
+		      int NumberToDrag1, float *DragList1[],
+		      int NumberToDrag2, FLOAT *DragList2[],
+		      int NumberToDrag3, Eint64 *DragList3[],
+		      int NumberToDrag4, particle_object **DragList4[])
+#else
 void ShellSortAndDrag(Eint64 List[], int N,
 		      int NumberToDrag1, float *DragList1[],
 		      int NumberToDrag2, FLOAT *DragList2[],
 		      int NumberToDrag3, Eint64 *DragList3[])
+#endif //End of USE_SLUG
 {
  
   int a, nn, i, j, m;
   Eint64 temp1, t11, t12[NumberToDrag3];
   float temp2, t2[NumberToDrag1];
   FLOAT temp3, t3[NumberToDrag2];
+#ifdef USE_SLUG
+  particle_object *temp4, *t4[NumberToDrag4];
+#endif //End of USE_SLUG
 
   m = N;
   for (nn = 1; nn <= N; nn <<= 1) {
 	t3[a] = DragList2[a][j];
       for (a = 0; a < NumberToDrag3; a++)
 	t12[a] = DragList3[a][j];
+#ifdef USE_SLUG
+      for (a = 0; a < NumberToDrag4; a++)
+	t4[a] = DragList4[a][j];
+#endif //End of USE_SLUG
 
       while (i >= 0 && List[i] > t11) {
 	SWAP(List, i+m, i, temp1);
 	  SWAP(DragList2[a], i+m, i, temp3);
 	for (a = 0; a < NumberToDrag3; a++)
 	  SWAP(DragList3[a], i+m, i, temp1);
+#ifdef USE_SLUG
+	for (a = 0; a < NumberToDrag4; a++)
+	  SWAP(DragList4[a], i+m, i, temp4);
+#endif //End of USE_SLUG
 	i -= m;
       }
 
 	DragList2[a][i+m] = t3[a];
       for (a = 0; a < NumberToDrag3; a++)
 	DragList3[a][i+m] = t12[a];
+#ifdef USE_SLUG
+      for (a = 0; a < NumberToDrag4; a++)
+	DragList4[a][i+m] = t4[a];
+#endif //End of USE_SLUG
 
     } // ENDFOR j
   } // ENDFOR nn
File src/enzo/StarParticleData.h MODIFIED
Side-by-side diff  View file   More
 #ifndef STAR_PARTICLE_DATA_DEFINED__
 #define STAR_PARTICLE_DATA_DEFINED__
 
+#ifdef USE_SLUG
+#include "particle_object.h"
+#endif //End of USE_SLUG
 #ifdef DEFINE_STORAGE
 # define SPEXTERN
 #else /* DEFINE_STORAGE */
   float Attribute[MAX_NUMBER_OF_PARTICLE_ATTRIBUTES];
   PINT Number;
   int Type;
+#ifdef USE_SLUG
+  particle_object *Object;
+#endif //End of USE_SLUG
 };
 
 
File src/enzo/WriteParameterFile.C MODIFIED
Side-by-side diff  View file   More
   fprintf(fptr, "NumberOfParticleAttributes            = %"ISYM"\n",
 	  NumberOfParticleAttributes);
 
+  /* Particle object handling */
+  #ifdef USE_SLUG
+  fprintf(fptr, "MaxBufferSizeParticleObject           = %"ISYM"\n", 
+          MaxBufferSizeParticleObject);
+  #endif
+
     /* Sink particles (for present day star formation) & winds */
   fprintf(fptr, "SinkMergeDistance                     = %"FSYM"\n", 
 	  SinkMergeDistance);
File src/enzo/global_data.h MODIFIED
Side-by-side diff  View file   More
 EXTERN double SimpleQ;
 EXTERN float SimpleRampTime;
 
+/* Particle object handling */
+#ifdef USE_SLUG
+EXTERN int MaxBufferSizeParticleObject;
+#endif
+
 /* Set this flag to allow star formation only once per root grid time
    step (at the beginning) and with a SFR proportional to the full
    root grid time step (as in Kravtsov 2004, for example). Currently
File src/enzo/particle_object.h ADDED
Side-by-side diff  View file   More
+/***********************************************************************
+/
+/  PARTICLE_OBJECT CLASS
+/
+/  written by: Yusuke Fujimoto
+/  date:       Jan, 2017
+/  modified:   
+/
+/  PURPOSE: Attach an arbitrary object to star particles
+/
+************************************************************************/
+
+// particle_object.h
+#ifndef particle_object__
+#define particle_object__
+
+class particle_object {
+
+public:
+  
+  // Default constructor; this does nothing
+  particle_object(){}
+  
+  // Virtual destructor; defined here so derived classes can override it
+  virtual ~particle_object(){}
+  
+};
+
+#endif
File src/enzo/particle_slug_object.C ADDED
Side-by-side diff  View file   More
+/***********************************************************************
+/
+/  MEMBER FUNCTIONS OF PARTICLE_SLUG_OBJECT CLASS
+/
+/  written by: Yusuke Fujimoto
+/  date:       Jan, 2017
+/  modified:   
+/
+/  PURPOSE: Define member functions of particle_slug_object class.
+/           See particle_slug_object.h
+/
+************************************************************************/
+
+// particle_slug_object.C
+#ifdef USE_SLUG
+#include "particle_slug_object.h"
+#include "slug_cluster.H"
+#include "slug_predefined.H"
+
+// Method to construct the slug_cluster object from particle mass
+void particle_slug_object::construct_cluster(double particle_mass) {
+
+  cluster = new slug_cluster(1, particle_mass, 0.0, 
+                             slug_predef.imf("chabrier", 9.0, POISSON), 
+                             slug_predef.tracks("modp020.dat"), 
+                             slug_predef.specsyn("sb99",
+                                                 slug_predef.tracks("modp020.dat"),
+                                                 slug_predef.imf("chabrier", 9.0, POISSON)), 
+                             slug_predef.filter_set("QH0"), 
+                             nullptr, nullptr, 
+                             slug_predef.yields("SNII_Sukhbold16_nodecay"),
+                             slug_predef.ostreams, nullptr, true);
+
+}
+
+// Method to reconstruct the slug_cluster object from a serialized buffer
+void particle_slug_object::reconstruct_cluster(char *buf) {
+
+  cluster = new slug_cluster((slug_cluster_buffer *) buf,
+                             slug_predef.imf("chabrier", 9.0, POISSON),
+                             slug_predef.tracks("modp020.dat"),
+                             slug_predef.specsyn("sb99",
+                                                 slug_predef.tracks("modp020.dat"),
+                                                 slug_predef.imf("chabrier", 9.0, POISSON)),
+                             slug_predef.filter_set("QH0"), 
+                             nullptr, nullptr, 
+                             slug_predef.yields("SNII_Sukhbold16_nodecay"),
+                             slug_predef.ostreams, nullptr, true);
+
+}
+
+// Method to return the member functions of the slug_cluster
+void particle_slug_object::pack_buffer(char *buf) { cluster->pack_buffer((slug_cluster_buffer *) buf); }
+int particle_slug_object::buffer_size() { return cluster->buffer_size(); }
+void particle_slug_object::advance(double particle_age) { cluster->advance(particle_age); }
+int particle_slug_object::get_stoch_sn() { return cluster->get_stoch_sn(); }
+double particle_slug_object::get_birth_mass() { return cluster->get_birth_mass(); }
+double particle_slug_object::get_stellar_mass() { return cluster->get_stellar_mass(); }
+double particle_slug_object::get_photometry_QH0() { return cluster->get_photometry()[0]; }
+double particle_slug_object::get_yields_Fe60() { return cluster->get_yields()[cluster->isotope_index(26,60)]; }
+double particle_slug_object::get_yields_Al26() { return cluster->get_yields()[cluster->isotope_index(13,26)]; }
+
+#endif //End of USE_SLUG
File src/enzo/particle_slug_object.h ADDED
Side-by-side diff  View file   More
+/***********************************************************************
+/
+/  PARTICLE_SLUG_OBJECT CLASS
+/
+/  written by: Yusuke Fujimoto
+/  date:       Jan, 2017
+/  modified:   
+/
+/  PURPOSE: Attach a slug_cluster object to star particles.
+/           SLUG is the Stochastically Lighting Up Galaxies Code. 
+/           SLUG is a stellar population synthesis code, and in many 
+/           respects is similar to other commonly-used SPS codes 
+/           such as starburst99 and FSPS.
+/           For more detail, see http://slug2.readthedocs.org/en/latest/
+/
+************************************************************************/
+
+// particle_slug_object.h
+#ifndef particle_slug_object__
+#define particle_slug_object__
+
+#include "particle_object.h"
+#include "slug.H"
+
+class particle_slug_object : public particle_object {
+  
+public:
+  
+  // Constructor 
+  particle_slug_object() { 
+    cluster = nullptr;
+  }
+  
+  // Destructor; this frees the slug_cluster object
+  virtual ~particle_slug_object() {
+    delete cluster;
+    cluster = nullptr;
+  }
+  
+  // Method to construct the slug_cluster object from particle mass
+  void construct_cluster(double particle_mass);
+  
+  // Method to reconstruct the slug_cluster object from a serialized buffer
+  void reconstruct_cluster(char *buf);
+
+  // Method to return the member functions of the slug_cluster
+  void pack_buffer(char *buf);
+  int buffer_size();
+  void advance(double particle_age); // particle_age [yr]
+  int get_stoch_sn();
+  double get_birth_mass();
+  double get_stellar_mass();
+  double get_photometry_QH0(); // ionising luminosity [photon/s]
+  double get_yields_Fe60();
+  double get_yields_Al26();
+  
+protected:
+  
+  // This is a pointer to the slug_cluster object
+  slug_cluster *cluster;
+  
+};
+
+#endif
File src/enzo/typedefs.h MODIFIED
Side-by-side diff  View file   More
 #include "RateData.h"
 #include "RadiationFieldData.h"
 #include "TestProblemData.h"
+#ifdef USE_SLUG
+#include "particle_object.h"
+#endif //End of USE_SLUG
 
 /* These are the different types of baryon fields. */
 
   float vel[MAX_DIMENSION];
   float mass;
   float attribute[MAX_NUMBER_OF_PARTICLE_ATTRIBUTES];
+#ifdef USE_SLUG
+  particle_object *object;
+#endif //End of USE_SLUG
   PINT  id;
   int   type;
   int   grid;