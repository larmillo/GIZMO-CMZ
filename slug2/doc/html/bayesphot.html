
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>bayesphot: Bayesian Inference for Stochastic Stellar Populations &#8212; slug 2.0 documentation</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '2.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="cluster_slug: Bayesian Inference of Star Cluster Properties" href="cluster_slug.html" />
    <link rel="prev" title="cloudy_slug: An Automated Interface to cloudy" href="cloudy.html" />
   
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9">

  </head>
  <body>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="bayesphot-bayesian-inference-for-stochastic-stellar-populations">
<span id="sec-bayesphot"></span><h1>bayesphot: Bayesian Inference for Stochastic Stellar Populations<a class="headerlink" href="#bayesphot-bayesian-inference-for-stochastic-stellar-populations" title="Permalink to this headline">¶</a></h1>
<div class="section" id="what-does-bayesphot-do">
<h2>What Does bayesphot Do?<a class="headerlink" href="#what-does-bayesphot-do" title="Permalink to this headline">¶</a></h2>
<p>Bayesphot is a package for performing Bayesian inference for the physical properties of a stellar system using its measured photometric properties, in a case where the photometric properties vary non-deterministically with the physical properties. Formally, bayesphot answers the following question: consider a stellar system characterized by a vector of <span class="math">\(\mathbf{x} = (x_1, x_2, \ldots x_N)\)</span> physical properties. We have a physical model that lets us sample the expected photometric properties as a function of physical properties, i.e., that for some sample of <span class="math">\(K\)</span> systems with physical properties <span class="math">\(\mathbf{x}_k\)</span> we are able to compute the corresponding photometric properties <span class="math">\(\mathbf{y}_k = \mathbf{y} = (y_1, y_2, \ldots y_M)_k\)</span>. Now suppose that we observe such a system, and we observe it to have photometric properties <span class="math">\(\mathbf{y}_{\mathrm{obs}}\)</span>, with some set of photometric errors <span class="math">\(\mathbf{\sigma}_{\mathbf{y}} = (\sigma_{y_1}, \sigma_{y_2}, \ldots \sigma_{y_M})\)</span>, which are assumed to be Gaussian-distributed. What should we infer about the posterior probability distribution of the physical properties, i.e., given a set of prior probabilities <span class="math">\(p(\mathbf{x})\)</span>, plus our measurements, what is <span class="math">\(p(\mathbf{x} \mid \mathbf{y}_{\mathrm{obs}}, \mathbf{\sigma}_{\mathrm{y}})\)</span>?</p>
<p>The kernel density estimation algorithm that bayesphot uses to answer this question is described and derived in the slug methods paper. Bayesphot is implemented in two parts: a shared object library that is implemented in c, and that is compiled at the same time that slug is built, and a python wrapper class called <code class="docutils literal"><span class="pre">bp</span></code> that is included in the slugpy.bayesphot module. The following sections describe how to use <code class="docutils literal"><span class="pre">bp</span></code> objects to generate posterior PDFs.</p>
</div>
<div class="section" id="creating-bp-objects">
<h2>Creating <code class="docutils literal"><span class="pre">bp</span></code> Objects<a class="headerlink" href="#creating-bp-objects" title="Permalink to this headline">¶</a></h2>
<p>The <code class="docutils literal"><span class="pre">bp</span></code> class can be imported via:</p>
<div class="highlight-rest"><div class="highlight"><pre><span></span>from slugpy.bayesphot import *
</pre></div>
</div>
<p>or:</p>
<div class="highlight-rest"><div class="highlight"><pre><span></span>from slugpy.bayesphot import bp
</pre></div>
</div>
<p>Once imported, a <code class="docutils literal"><span class="pre">bp</span></code> object can be instantiated. The call signature for the <code class="docutils literal"><span class="pre">bp</span></code> constructor class is:</p>
<div class="highlight-rest"><div class="highlight"><pre><span></span>def __init__(self, dataset, nphys, filters=None, bandwidth=&#39;auto&#39;,
             ktype=&#39;gaussian&#39;, priors=None, sample_density=None,
             reltol=1.0e-3, abstol=1.0e-10, leafsize=16):
</pre></div>
</div>
<p>A full description of all options is included in the <a class="reference internal" href="#ssec-slugpy-bayesphot"><span class="std std-ref">Full Documentation of slugpy.bayesphot</span></a>, but the essential features are summarized here.</p>
<p>The argument <code class="docutils literal"><span class="pre">dataset</span></code> is an array of shape (N, M) that contains the library of N models that represents the training set for the Bayesian analysis. Each model consists of M properties; the first <code class="docutils literal"><span class="pre">nphys</span></code> of these are physical properties that are the quantities to be inferred from the observations, while the remaining ones are photometric properties. An important point is that the <code class="docutils literal"><span class="pre">dataset</span></code> object is NOT copied, so altering it after the <code class="docutils literal"><span class="pre">bp</span></code> object is created will result in erroneous results.</p>
<p>The <code class="docutils literal"><span class="pre">priors</span></code> and <code class="docutils literal"><span class="pre">sample_density</span></code> arguments are used to compute the weighting to apply to the input models. The <code class="docutils literal"><span class="pre">priors</span></code> argument specifies the prior probability to assign to each model; it can be either an array giving a prior probability directly, or a callable that can take the physical properties of models as an input and return the prior probability as an output. Similarly, the <code class="docutils literal"><span class="pre">sample_density</span></code> argument specifies the probablity distribution from which the physical models were selected; as with <code class="docutils literal"><span class="pre">priors</span></code>, it can be an array or a callable.</p>
<p>The <code class="docutils literal"><span class="pre">bandwidth</span></code> argument specifies the bandwidth to use in the kernel density estimation; this need not be the same in each dimension. The <code class="docutils literal"><span class="pre">bandwidth</span></code> can be specified as a float, in which case it is the same for every dimension, or as an array of M elements giving the bandwidth for every dimension. Finally, it can be set to the string <code class="docutils literal"><span class="pre">auto</span></code>, in which case the <code class="docutils literal"><span class="pre">bp</span></code> will attempt to make a reasonable choice of bandwidth autonomously. However, this autonomous choice will probably perform less well than something that is hand-chosen by the user based on their knowledge of the library. As a rule of thumb, bandwidths should be chosen so that, for typical input photometric values, there are ~10 simulations within the 1 kernel size.</p>
<p>Note that both <code class="docutils literal"><span class="pre">priors</span></code> and <code class="docutils literal"><span class="pre">bandwidth</span></code> are properties of the <code class="docutils literal"><span class="pre">bp</span></code> class, and can be altered after the <code class="docutils literal"><span class="pre">bp</span></code> object is created. This makes it possible to alter the priors and bandwidth without incurring the computational or memory cost of generating an entirely new <code class="docutils literal"><span class="pre">bp</span></code> object.</p>
</div>
<div class="section" id="using-bp-objects">
<h2>Using <code class="docutils literal"><span class="pre">bp</span></code> Objects<a class="headerlink" href="#using-bp-objects" title="Permalink to this headline">¶</a></h2>
<p>Once a <code class="docutils literal"><span class="pre">bp</span></code> object is instantiated, it can be used to compute likelihood functions, marginal probabilities, and MCMC sample ensembles, and to search the library for the best matches to an input set of photometry.</p>
<p>The likelihood function is implemented via the <code class="docutils literal"><span class="pre">bp.logL</span></code> method, which has the call signature:</p>
<div class="highlight-rest"><div class="highlight"><pre><span></span>def logL(self, physprop, photprop, photerr=None):
</pre></div>
</div>
<p>The argument <code class="docutils literal"><span class="pre">physprop</span></code> is a set of physical properties, the argument <code class="docutils literal"><span class="pre">photprop</span></code> is a set of photometric properties, and the argument <code class="docutils literal"><span class="pre">photerr</span></code> is an (optional) set of photometric errors. All of these must be arrays, the size of whose trailing dimension matches the number of physical properties (for <code class="docutils literal"><span class="pre">physprop</span></code>) or the number of photometric properties (for <code class="docutils literal"><span class="pre">photprop</span></code> and <code class="docutils literal"><span class="pre">photerr</span></code>); the leading dimensions of these arrays are broadcast together using normal broadcasting rules. The quantity returned is the log of the joint probability distribution of physical and photometric properties. Specifically, the quantity returned for each input set of physical and photometric properties is</p>
<div class="math">
\[\log p(\mathbf{x}, \mathbf{y}, \sigma_{\mathbf{y}}) = \log A \sum_{i=1}^N w_i G(\mathbf{x}, \mathbf{y}; \mathbf{h}')\]</div>
<p>where <span class="math">\(A\)</span> is a normalization constant chosen to ensure that the PDF integrated over all space is unity, <span class="math">\(\mathbf{x}\)</span> is the vector of physical properties, <span class="math">\(\mathbf{y}\)</span> is the vector of photometric properties, <span class="math">\(\sigma_\mathbf{y}\)</span> is the vector of photomtric errors, <span class="math">\(w_i\)</span> is the weight of the ith model as determined by the priors and sample density,</p>
<div class="math">
\[G\left(\mathbf{x}, \mathbf{y}; \mathbf{h}'\right) \propto \exp\left[-\left(\frac{x_1^2}{2h_{x_1}'^2} + \cdots + \frac{x_N^2}{2h_{x_N}'^2} + \frac{y_1^2}{2h_{y_1}'^2} + \cdots + \frac{y_M^2}{2h_{y_M}'^2} \right)\right]\]</div>
<p>is the N-dimensional Gaussian function, and</p>
<div class="math">
\[\mathbf{h'} = \sqrt{\mathbf{h}^2 + \sigma_{\mathbf{y}}^2}\]</div>
<p>is the modified bandwidth, which is equal to the bandwidth used for kernel density estimation added in quadrature sum with the errors in the photometric quantities (see the slug method paper for details).</p>
<p>Estimation of marginal PDFs is done via the <code class="docutils literal"><span class="pre">bp.mpdf</span></code> method, which has the call signature:</p>
<div class="highlight-rest"><div class="highlight"><pre><span></span>def mpdf(self, idx, photprop, photerr=None, ngrid=128,
         qmin=None, qmax=None, grid=None, norm=True):
</pre></div>
</div>
<p>The argument <code class="docutils literal"><span class="pre">idx</span></code> is an int or a list of ints between 0 and nphys-1, which specifies for which physical quantity or physical quantities the marginal PDF is to be computed. These indices refer to the indices in the <code class="docutils literal"><span class="pre">dataset</span></code> array that was input when the <code class="docutils literal"><span class="pre">bp</span></code> object was instantiated. The arguments <code class="docutils literal"><span class="pre">photprop</span></code> and <code class="docutils literal"><span class="pre">photerr</span></code> give the photometric measurements and their errors for which the marginal PDFs are to be computed; they must be arrays whose trailing dimension is equal to the number of photometric quantities. The leading dimensions of these arrays are broadcast together following the normal broadcasting rules. By default each physical quantity will be estimated on a grid of 128 points, evenly spaced from the lowest value of that physical property in the model library to the highest value. The parameters <code class="docutils literal"><span class="pre">qmin</span></code>, <code class="docutils literal"><span class="pre">qmax</span></code>, <code class="docutils literal"><span class="pre">ngrid</span></code>, and <code class="docutils literal"><span class="pre">grid</span></code> can be used to override this behavior and set the grid of evaluation points manually. The function returns a tuple <code class="docutils literal"><span class="pre">grid_out,</span> <span class="pre">pdf</span></code>; here <code class="docutils literal"><span class="pre">grid_out</span></code> is the grid of points on which the marginal PDF has been computed, and <code class="docutils literal"><span class="pre">pdf</span></code> is the value of the marginal PDF evaluated at those gridpoints.</p>
<p>MCMC calculations are implemented via the method <code class="docutils literal"><span class="pre">bp.mcmc</span></code>; this method relies on the <a class="reference external" href="http://dan.iel.fm/emcee/current/">emcee</a> python module, and will only function if it is installed. The call signature is:</p>
<div class="highlight-rest"><div class="highlight"><pre><span></span>def mcmc(self, photprop, photerr=None, mc_walkers=100,
         mc_steps=500, mc_burn_in=50):
</pre></div>
</div>
<p>The quantities <code class="docutils literal"><span class="pre">photprop</span></code> and <code class="docutils literal"><span class="pre">photerr</span></code> have the same meaning as for <code class="docutils literal"><span class="pre">bp.mpdf</span></code>, and the quantities <code class="docutils literal"><span class="pre">mc_walkers</span></code>, <code class="docutils literal"><span class="pre">mc_steps</span></code>, and <code class="docutils literal"><span class="pre">mc_burn_in</span></code> are passed directly to <code class="docutils literal"><span class="pre">emcee</span></code>, and are described in <a class="reference external" href="http://dan.iel.fm/emcee/current/">emcee’s documentation</a>. The quantity returned is an array of sample points computed by the MCMC; its format is also described in <a class="reference external" href="http://dan.iel.fm/emcee/current/">emcee’s documentation</a>. Note that, although <code class="docutils literal"><span class="pre">bp.mcmc</span></code> can be used to compute marginal PDFs of the physical quantities, for marginal PDFs of 1 quantity or joint PDFs of 2 quantities it is almost always faster to use <code class="docutils literal"><span class="pre">bp.mpdf</span></code> than <code class="docutils literal"><span class="pre">bp.mcmc</span></code>. This is because <code class="docutils literal"><span class="pre">bp.mpdf</span></code> takes advantage of the fact that integrals of cuts through N-dimensional Gaussians can be integrated analytically to compute the marginal PDFs directly, though needing to evaluate the likelihood function point by point. In contrast, the general MCMC algorithm used by <code class="docutils literal"><span class="pre">emcee</span></code> effectively does the integral numerically.</p>
<p>The <code class="docutils literal"><span class="pre">bp.bestmatch</span></code> method searches through the model library and finds the N library entries that are closest to an input set of photometry. The call signature is:</p>
<div class="highlight-rest"><div class="highlight"><pre><span></span>def bestmatch(self, phot, nmatch=1, bandwidth_units=False):
</pre></div>
</div>
<p>Here <code class="docutils literal"><span class="pre">phot</span></code> is the set of photometric properties, which is identical to the <code class="docutils literal"><span class="pre">photprop</span></code> parameter used by <code class="docutils literal"><span class="pre">logL</span></code>, <code class="docutils literal"><span class="pre">mpdf</span></code>, and <code class="docutils literal"><span class="pre">mcmc</span></code>. The argument <code class="docutils literal"><span class="pre">nmatch</span></code> specifies how many matches to return, and the argument <code class="docutils literal"><span class="pre">bandwidth_units</span></code> specifies whether distances are to be measured using an ordinary Euclidean metric, or in units of the kernel bandwidth in a given direction. The function returns, for each input set of photometry, the physical and photometric properties of the <code class="docutils literal"><span class="pre">nmatch</span></code> models in the library that are closest to the input photometric values. This can be used to judge if a good match to the input photometry is present in the library.</p>
</div>
<div class="section" id="caching">
<h2>Caching<a class="headerlink" href="#caching" title="Permalink to this headline">¶</a></h2>
<p>The <code class="docutils literal"><span class="pre">bp</span></code> class is built to compute posterior PDFs of some
quantities, marginalising over others. To speed this process, it uses
an internal KD tree representation of the data. By default the KD tree
spans all physical and photometric dimensions of the underlying data
set. When marginalising over some dimensions, however, it can be much
more efficient to have a KD tree that only spans the dimensions that
are not being marginalised, particularly if there are many of
them. For example, suppose that we have a library of sample star
clusters with a range of masses, ages, extinctions, metallicities, and
photometric measurements. We are interested in the posterior PDF of
mass given a set of photometry, marginalising over age, extinction,
and metallicity. In this case it is more efficient to have a KD tree
that does not split in the age, extinction, or metallicity
dimensions. Since evaluating the marginal posterior PDF of mass using
such a tree is much faster, if we are going to compute marginal
posterior PDFs of mass many times (for example for many photometric
measurements) it is advantageous to pay the one-time cost of
constructing the better-optimised KD tree and then use it for all
subsequent calculations.</p>
<p>To handle this, <code class="docutils literal"><span class="pre">bp</span></code> has an optional caching capability that will
cache KD tree representations of the data that are optimal for
computing posterior PDFs marginalised over certain dimensions. One can
construct such a cached tree by invoking the <code class="docutils literal"><span class="pre">bp.make_cache</span></code>
method. The syntax is simple:</p>
<div class="highlight-rest"><div class="highlight"><pre><span></span>bp.make_cache(margindims)
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">margindims</span></code> is a listlike containing the dimensions that will
be marginalized out. Once created, the cache will be used for all
subsequent evaluations using <code class="docutils literal"><span class="pre">bp.mpdf</span></code> and related methods
(<code class="docutils literal"><span class="pre">mpdf_phot</span></code> and <code class="docutils literal"><span class="pre">mpdf_gen</span></code>) that marginalise over those
dimensions.</p>
<p>Caching can also be done automatically. The <code class="docutils literal"><span class="pre">bp</span></code> constructor accepts
the keyword <code class="docutils literal"><span class="pre">caching</span></code> which specifies the type of caching to
use. The default value, <code class="docutils literal"><span class="pre">none</span></code>, uses no caching. The value <code class="docutils literal"><span class="pre">lazy</span></code>
causes a cached KD tree to be build whenever one of the marginal PDF
methods is invoked, and is stored for future use. (Warning: <code class="docutils literal"><span class="pre">lazy</span></code>
mode is not thread-safe – see <a class="reference internal" href="#ssec-bayesphot-threading"><span class="std std-ref">Parallelism in bayesphot</span></a>.)
Finally, <code class="docutils literal"><span class="pre">aggressive</span></code> mode constructs caches for all possible
one-dimensional marginalisations of physical variables given observed
photometry, and all possible one-dimensional marginalisations of
variables by themselves, when the <code class="docutils literal"><span class="pre">bp</span></code> object is first constructed.</p>
</div>
<div class="section" id="parallelism-in-bayesphot">
<span id="ssec-bayesphot-threading"></span><h2>Parallelism in bayesphot<a class="headerlink" href="#parallelism-in-bayesphot" title="Permalink to this headline">¶</a></h2>
<p>The <code class="docutils literal"><span class="pre">bp</span></code> class supports parallel calculations of posterior PDFs and
related quantities, through the python <a class="reference external" href="https://docs.python.org/2.7/library/multiprocessing.html">multiprocessing module</a>. This
allows efficient use of multiple cores on a shared memory machine,
circumventing the python global interpreter lock, without the need for
every process to read a large simulation library or store it in
memory. The recommended method for writing threaded code using <code class="docutils literal"><span class="pre">bp</span></code>
objects is to use have a master process create the <code class="docutils literal"><span class="pre">bp</span></code> object, and
then use a <a class="reference external" href="https://docs.python.org/2.7/library/multiprocessing.html#multiprocessing.Process">Process</a>
or <a class="reference external" href="https://docs.python.org/2.7/library/multiprocessing.html#module-multiprocessing.pool">Pool</a>
object to create child processes the perform computations using <code class="docutils literal"><span class="pre">bp</span></code>
methods such as <code class="docutils literal"><span class="pre">bp.logL</span></code> or <code class="docutils literal"><span class="pre">bp.mpdf</span></code>. It is often most efficient
to combine this with shared memory objects such as <a class="reference external" href="https://docs.python.org/2.7/library/multiprocessing.html#module-multiprocessing.sharedctypes">RawArray</a>
to hold the outputs.</p>
<p>An example use case for computing 1D marginal PDFs on a large set of photometric values is:</p>
<div class="highlight-rest"><div class="highlight"><pre><span></span># Import what we need
from slugpy.bayesphot import bp
from multiprocessing import Pool, RawArray
from ctypes import c_double
import numpy as np

# Some code here to create / read the data set to be used by
# bayesphot and store it in a variable called dataset

# Create the bayesphot object
my_bp = bp(dataset, nphys)

# Some code here to create / read the photometric data we want to
# process using bayesphot and store it in an array called phot,
# which is of shape (nphot, nfilter). There is also an array of
# photometric errors, called photerr, of the same shape.

# Create a holder for the output
pdf_base = RawArray(c_double, 128*nphot)
pdf = np.frombuffer(pdf_base, dtype=c_double). \
      reshape((nphot,128))
grd_base = RawArray(c_double, 128)
grd = np.frombuffer(grd_base, dtype=c_double)

# Define the function that will be responsible for computing the
# marginal PDF
def mpdf_apply(i):
    grd[:], pdf[i] = my_bp.mpdf(0, phot[i], photerr[i])

# Main thread starts up a process pool and starts the computation
if __name__ == &#39;__main__&#39;:
    pool = Pool()
    pool.map(mpdf_apply, range(nphot))

    # At this point the grd and PDF contain the same as they would
    # if we had done
    #     grd, pdf = my_bp.mpdf(0, phot, photerr)
    # but the results will be computed much faster this way
</pre></div>
</div>
<p>For an example of a more complex use case, see the <a class="reference external" href="https://bitbucket.org/krumholz/legus-cluster-pipeline/overview">LEGUS cluster pipeline</a>.</p>
<p>The full list of <code class="docutils literal"><span class="pre">bp</span></code> methods that are thread-safe is:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">bp.logL</span></code></li>
<li><code class="docutils literal"><span class="pre">bp.mpdf</span></code></li>
<li><code class="docutils literal"><span class="pre">bp.mcmc</span></code></li>
<li><code class="docutils literal"><span class="pre">bp.bestmatch</span></code></li>
<li><code class="docutils literal"><span class="pre">bp.make_approx_phot</span></code></li>
<li><code class="docutils literal"><span class="pre">bp.make_approx_phys</span></code></li>
<li><code class="docutils literal"><span class="pre">bp.squeeze_rep</span></code></li>
<li><code class="docutils literal"><span class="pre">bp.mpdf_approx</span></code></li>
</ul>
<p>Thread safety involves a very modest overhead in terms of memory and speed, but for non-threaded computations this can be avoided by specifying:</p>
<div class="highlight-rest"><div class="highlight"><pre><span></span>bp.thread_safe = False
</pre></div>
</div>
<p>or by setting the <code class="docutils literal"><span class="pre">thread_safe</span></code> keyword to <code class="docutils literal"><span class="pre">False</span></code> when the <code class="docutils literal"><span class="pre">bp</span></code>
object is constructed.</p>
<p>Finally, note that this parallel paradigm avoids duplicating the large
library only on unix-like operating systems that support copy-on-write
semantics for <a class="reference external" href="https://en.wikipedia.org/wiki/Fork_(system_call)">fork</a>. Code such as the
above example should still work on windows (though this has not been
tested), but each worker process will duplicate the library in
physical memory, thereby removing one of the main advantages of
working in parallel.</p>
</div>
<div class="section" id="module-slugpy.bayesphot.bp">
<span id="full-documentation-of-slugpy-bayesphot"></span><span id="ssec-slugpy-bayesphot"></span><h2>Full Documentation of slugpy.bayesphot<a class="headerlink" href="#module-slugpy.bayesphot.bp" title="Permalink to this headline">¶</a></h2>
<p>This defines a class that can be used to estimate the PDF of physical
quantities from a set of input photometry in various bands, together
with a training data set.</p>
<dl class="class">
<dt id="slugpy.bayesphot.bp.bp">
<em class="property">class </em><code class="descclassname">slugpy.bayesphot.bp.</code><code class="descname">bp</code><span class="sig-paren">(</span><em>dataset</em>, <em>nphys</em>, <em>filters=None</em>, <em>bandwidth='auto'</em>, <em>ktype='gaussian'</em>, <em>priors=None</em>, <em>pobs=None</em>, <em>sample_density=None</em>, <em>reltol=0.01</em>, <em>abstol=1e-10</em>, <em>leafsize=16</em>, <em>nosort=None</em>, <em>thread_safe=True</em>, <em>caching='none'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/slugpy/bayesphot/bp.html#bp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#slugpy.bayesphot.bp.bp" title="Permalink to this definition">¶</a></dt>
<dd><p>A class that can be used to estimate the PDF of the physical
properties of stellar population from a training set plus a set of
measured photometric values.</p>
<dl class="docutils">
<dt>Properties</dt>
<dd><dl class="first last docutils">
<dt>priors <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (N) | callable | None</span></dt>
<dd>prior probability on each data point; interpretation
depends on the type passed; array, shape (N): values are
interpreted as the prior probability of each data point;
callable: the callable must take as an argument an array
of shape (N, nphys), and return an array of shape (N)
giving the prior probability at each data point; None:
no reweighting is performed, so all data points in the library
have equal prior probability, i.e. the prior is the same as
the sampling of points in the library</dd>
<dt>pobs <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (N) | callable | None</span></dt>
<dd>the probability that a particular object would be observed,
which is used, like prior, to weight the library;
interpretation depends on type. None means all objects are
equally likely to be observed, array is an array giving the
observation probability of each object in the library, and
callable means must be a function that takes an array
containing the photometry, of shape (N, nhpot), as an
argument, and returns an array of shape (N) giving the
probability of observation for that object</dd>
<dt>bandwidth <span class="classifier-delimiter">:</span> <span class="classifier">‘auto’ | float | array, shape (M)</span></dt>
<dd>bandwidth for kernel density estimation; if set to
‘auto’, the bandwidth will be estimated automatically; if
set to a scalar quantity, the same bandwidth is used for all
dimensions</dd>
<dt>nphys <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of physical properties in the library</dd>
<dt>nphot <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of photometric properties in the library</dd>
<dt>ndim <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>nphys + nphot</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="slugpy.bayesphot.bp.bp.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>dataset</em>, <em>nphys</em>, <em>filters=None</em>, <em>bandwidth='auto'</em>, <em>ktype='gaussian'</em>, <em>priors=None</em>, <em>pobs=None</em>, <em>sample_density=None</em>, <em>reltol=0.01</em>, <em>abstol=1e-10</em>, <em>leafsize=16</em>, <em>nosort=None</em>, <em>thread_safe=True</em>, <em>caching='none'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/slugpy/bayesphot/bp.html#bp.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#slugpy.bayesphot.bp.bp.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize a bp object.</p>
<dl class="docutils">
<dt>Parameters</dt>
<dd><dl class="first last docutils">
<dt>dataset <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (N, M)</span></dt>
<dd>training data set; this is a set of N sample stellar
populations, having M properties each; the first nphys
represent physical properties (e.g., log mass, log age),
while the next M - nphys represent photometric
properties</dd>
<dt>nphys <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of physical properties in dataset</dd>
<dt>filters <span class="classifier-delimiter">:</span> <span class="classifier">listlike of strings</span></dt>
<dd>names of photometric filters; not used, but can be
stored for convenience</dd>
<dt>bandwidth <span class="classifier-delimiter">:</span> <span class="classifier">‘auto’ | float | array, shape (M)</span></dt>
<dd>bandwidth for kernel density estimation; if set to
‘auto’, the bandwidth will be estimated automatically; if
set to a scalar quantity, the same bandwidth is used for all
dimensions</dd>
<dt>ktype <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd>type of kernel to be used in densty estimation; allowed
values are ‘gaussian’ (default), ‘epanechnikov’, and
‘tophat’; only Gaussian can be used with error bars</dd>
<dt>priors <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (N) | callable | None</span></dt>
<dd>prior probability on each data point; interpretation
depends on the type passed; array, shape (N): values are
interpreted as the prior probability of each data point;
callable: the callable must take as an argument an array
of shape (N, nphys), and return an array of shape (N)
giving the prior probability at each data point; None:
all data points have equal prior probability</dd>
<dt>pobs <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (N) | callable | None</span></dt>
<dd>the probability that a particular object would be observed,
which is used, like prior, to weight the library;
interpretation depends on type. None means all objects are
equally likely to be observed, array is an array giving the
observation probability of each object in the library, and
callable means must be a function that takes an array
containing the photometry, of shape (N, nhpot), as an
argument, and returns an array of shape (N) giving the
probability of observation for that object</dd>
<dt>sample_density <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (N) | callable | ‘auto’ | None</span></dt>
<dd>the density of the data samples at each data point; this
need not match the prior density; interpretation depends
on the type passed; array, shape (N): values are
interpreted as the density of data sampling at each
sample point; callable: the callable must take as an
argument an array of shape (N, nphys), and return an
array of shape (N) giving the sampling density at each
point; ‘auto’: the sample density will be computed
directly from the data set; note that this can be quite
slow for large data sets, so it is preferable to specify
this analytically if it is known; None: data are assumed
to be uniformly sampled</dd>
<dt>reltol <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>relative error tolerance; errors on all returned
probabilities p will satisfy either
abs(p_est - p_true) &lt;= reltol * p_est   OR
abs(p_est - p_true) &lt;= abstol,
where p_est is the returned estimate and p_true is the
true value</dd>
<dt>abstol <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>absolute error tolerance; see above</dd>
<dt>leafsize <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of data points in each leaf of the KD tree</dd>
<dt>nosort <span class="classifier-delimiter">:</span> <span class="classifier">arraylike of bool, shape (N) | None</span></dt>
<dd>if specified, this keyword causes the KD tree not to be
sorted along the dimensions for which nosort is True</dd>
<dt>thread_safe <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>if True, bayesphot will make extra copies of internals
as needed to ensure thread safety when the computation
routines (logL, mpdf, mcmc, bestmatch, make_approx_phot,
make_approx_phys, mpdf_approx) are used with
multiprocessing; this incurs a minor performance
penalty, and can be disabled by setting to False if the
code will not be run with the multiprocessing module</dd>
<dt>caching <span class="classifier-delimiter">:</span> <span class="classifier">‘aggressive’ | ‘lazy’ | ‘none’</span></dt>
<dd><p class="first">strategy for caching subsets of the data with some
dimensions marginalised out; behavior is as follows:</p>
<blockquote class="last">
<div><dl class="docutils">
<dt>‘agressive’</dt>
<dd>on construction, store sorted data for fast
calculation of 1D PDFs of variables by themselves,
and 1D PDFs of all physical variables marginalised
over all other physical variables; this
significantly increases the memory footprint and
construction time, but greatly speeds up
subsequent evaluation of any of these quantities,
and is generally the best choice for prudction
work in parallel</dd>
<dt>‘lazy’</dt>
<dd>sorted data sets for fast computation are created
and cached as needed; this will make the first
computation of any marginal PDF slower, but speed
up all subsequent ones, without imposing any
extra time at initial construction; this mode is
generally best for interactive work, but is not
thread_safe = True; memory cost depends on how
many different marginal PDF combinations are
calculated, but is always less than aggressive</dd>
<dt>‘none’</dt>
<dd>no caching is performed automatically; the user
may still manually cache data by calling
the make_cache method</dd>
</dl>
</div></blockquote>
</dd>
</dl>
</dd>
<dt>Returns</dt>
<dd>Nothing</dd>
<dt>Raises</dt>
<dd>IOError, if the bayesphot c library cannot be found</dd>
<dt>Notes</dt>
<dd><p class="first">Because the data sets passed in may be large, this class
does not make copies of any of its arguments, and instead
modifies them in place. However, this means it is the
responsibility of the user not to alter the any of the
arguments once they are passed to this class; for example,
dataset must not be modified after it is passed. Altering the
arguments, except through this class’s methods, may cause
incorrect results to be generated.</p>
<p class="last">Caching with ‘aggressive’ or ‘lazy’ does create significant
memory overhead.</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="slugpy.bayesphot.bp.bp.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#slugpy.bayesphot.bp.bp.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="attribute">
<dt id="slugpy.bayesphot.bp.bp.bandwidth">
<code class="descname">bandwidth</code><a class="headerlink" href="#slugpy.bayesphot.bp.bp.bandwidth" title="Permalink to this definition">¶</a></dt>
<dd><p>The current bandwidth</p>
</dd></dl>

<dl class="method">
<dt id="slugpy.bayesphot.bp.bp.bestmatch">
<code class="descname">bestmatch</code><span class="sig-paren">(</span><em>phot</em>, <em>photerr=None</em>, <em>nmatch=1</em>, <em>bandwidth_units=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/slugpy/bayesphot/bp.html#bp.bestmatch"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#slugpy.bayesphot.bp.bp.bestmatch" title="Permalink to this definition">¶</a></dt>
<dd><p>Searches through the simulation library and returns the closest
matches to an input set of photometry.</p>
<dl class="docutils">
<dt>Parameters:</dt>
<dd><dl class="first last docutils">
<dt>phot <span class="classifier-delimiter">:</span> <span class="classifier">arraylike, shape (nfilter) or (…, nfilter)</span></dt>
<dd>array giving the photometric values; for a
multidimensional array, the operation is vectorized over
the leading dimensions</dd>
<dt>photerr <span class="classifier-delimiter">:</span> <span class="classifier">arraylike, shape (nfilter) or (…, nfilter)</span></dt>
<dd>array giving photometric errors, which must have the
same shape as phot; if this is not None,
then distances will be measured in units of the
photometric error if bandwidth_units is False, or in
units of the bandwidth added in quadrature with the
errors if it is True</dd>
<dt>nmatch <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of matches to return; returned matches will be
ordered by distance from the input</dd>
<dt>bandwidth_units <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>if False, distances are computed based on the
logarithmic difference in luminosity; if True, they are
measured in units of the bandwidth</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>matches <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (…, nmatch, nphys + nfilter)</span></dt>
<dd>best matches to the input photometry; shape in the
leading dimensions will be the same as for phot, and if
nmatch == 1 then that dimension will be omitted</dd>
<dt>dist <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (…, nmatch)</span></dt>
<dd>distances between the matches and the input photometry</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="slugpy.bayesphot.bp.bp.bestmatch_phys">
<code class="descname">bestmatch_phys</code><span class="sig-paren">(</span><em>phys</em>, <em>nmatch=1</em>, <em>bandwidth_units=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/slugpy/bayesphot/bp.html#bp.bestmatch_phys"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#slugpy.bayesphot.bp.bp.bestmatch_phys" title="Permalink to this definition">¶</a></dt>
<dd><p>Searches through the simulation library and returns the closest
matches to an input set of photometry.</p>
<dl class="docutils">
<dt>Parameters:</dt>
<dd><dl class="first last docutils">
<dt>phot <span class="classifier-delimiter">:</span> <span class="classifier">arraylike, shape (nphys) or (…, nphys)</span></dt>
<dd>array giving the physical values; for a
multidimensional array, the operation is vectorized over
the leading dimensions</dd>
<dt>nmatch <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of matches to return; returned matches will be
ordered by distance from the input</dd>
<dt>bandwidth_units <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>if False, distances are computed based on the
logarithmic difference in physical properties; if True,
they are measured in units of the bandwidth</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>matches <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (…, nmatch, nphys + nfilter)</span></dt>
<dd>best matches to the input properties; shape in the
leading dimensions will be the same as for phot, and if
nmatch == 1 then that dimension will be omitted</dd>
<dt>dist <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (…, nmatch)</span></dt>
<dd>distances between the matches and the input physical
properties</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="slugpy.bayesphot.bp.bp.clear_cache">
<code class="descname">clear_cache</code><span class="sig-paren">(</span><em>margindims=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/slugpy/bayesphot/bp.html#bp.clear_cache"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#slugpy.bayesphot.bp.bp.clear_cache" title="Permalink to this definition">¶</a></dt>
<dd><p>This method deletes from the cache</p>
<dl class="docutils">
<dt>Parameters</dt>
<dd><dl class="first last docutils">
<dt>margindims <span class="classifier-delimiter">:</span> <span class="classifier">listlike of integers</span></dt>
<dd>list of marginalised dimensions that should be removed
from the cache, in the same format as make_cache; if
left as None, the cache is completely emptied</dd>
</dl>
</dd>
<dt>Returns</dt>
<dd>Nothing</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="slugpy.bayesphot.bp.bp.draw_phot">
<code class="descname">draw_phot</code><span class="sig-paren">(</span><em>physprop</em>, <em>physidx=None</em>, <em>photerr=None</em>, <em>nsample=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/slugpy/bayesphot/bp.html#bp.draw_phot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#slugpy.bayesphot.bp.bp.draw_phot" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a randomly-drawn sample of photometric properties for
one or more input sets of physical properties.</p>
<dl class="docutils">
<dt>Parameters:</dt>
<dd><dl class="first last docutils">
<dt>physprop <span class="classifier-delimiter">:</span> <span class="classifier">arraylike</span></dt>
<dd>physical properties to be used; the final dimension of
the input must have len(physidx) indices, or nphys
indicates if physidx is None; if the input is a
multidimensional array, the operation is vectorized over
the leading dimensions physical properties</dd>
<dt>physidx <span class="classifier-delimiter">:</span> <span class="classifier">arraylike</span></dt>
<dd>indices of the physical quantities being constrained; if
left as None, all physical properties are set, and
physprop must have a trailing dimension of size equal to
nphys; otherwise this must be an arraylike of &lt;= nphys
positive integers, each unique and in the range [0,
nphys), specying which physical dimensions are
constrained</dd>
<dt>photerr <span class="classifier-delimiter">:</span> <span class="classifier">arraylike, shape (nphot)</span></dt>
<dd>photometric errors to apply to the output photometry;
these are added in quadrature with the kernel density
estimation bandwidth</dd>
<dt>nsample <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of random samples to draw for each set of
physical properties; must be positive</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>samples <span class="classifier-delimiter">:</span> <span class="classifier">arraylike</span></dt>
<dd>sample of photometric properties; the shape of the
output is (…, nsample, nphot), where nphot is the
number of photometric properties, and the leading
dimension(s) match the leading dimension(s) of physprop</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="slugpy.bayesphot.bp.bp.draw_sample">
<code class="descname">draw_sample</code><span class="sig-paren">(</span><em>photerr=None</em>, <em>nsample=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/slugpy/bayesphot/bp.html#bp.draw_sample"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#slugpy.bayesphot.bp.bp.draw_sample" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a randomly-drawn sample of physical and photometric
properties from the kernel density function</p>
<dl class="docutils">
<dt>Parameters:</dt>
<dd><dl class="first last docutils">
<dt>nsample <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of random samples to draw for each set of
physical properties; must be positive</dd>
<dt>photerr <span class="classifier-delimiter">:</span> <span class="classifier">arraylike, shape (nphot)</span></dt>
<dd>photometric errors to apply to the output photometry;
these are added in quadrature with the kernel density
estimation bandwidth</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>samples <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (nsample, nphys+nphot)</span></dt>
<dd>random sample drawn from the kernel density object; for
the final dimension in the output, the first nphys
elements are the physical quantities, the next nphot are
the photometric quantities</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="slugpy.bayesphot.bp.bp.logL">
<code class="descname">logL</code><span class="sig-paren">(</span><em>physprop</em>, <em>photprop</em>, <em>photerr=None</em>, <em>margindim=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/slugpy/bayesphot/bp.html#bp.logL"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#slugpy.bayesphot.bp.bp.logL" title="Permalink to this definition">¶</a></dt>
<dd><p>This function returns the natural log of the likelihood
function evaluated at a particular log mass, log age,
extinction, and set of log luminosities</p>
<dl class="docutils">
<dt>Parameters</dt>
<dd><dl class="first last docutils">
<dt>physprop <span class="classifier-delimiter">:</span> <span class="classifier">arraylike, shape (nphys) or (…, nphys)</span></dt>
<dd>array giving values of the physical properties; for a
multidimensional array, the operation is vectorized over
the leading dimensions</dd>
<dt>photprop <span class="classifier-delimiter">:</span> <span class="classifier">arraylike, shape (nfilter) or (…, nfilter)</span></dt>
<dd>array giving the photometric values; for a
multidimensional array, the operation is vectorized over
the leading dimensions</dd>
<dt>photerr <span class="classifier-delimiter">:</span> <span class="classifier">arraylike, shape (nfilter) or (…, nfilter)</span></dt>
<dd>array giving photometric errors; for a multidimensional
array, the operation is vectorized over the leading
dimensions</dd>
<dt>margindim <span class="classifier-delimiter">:</span> <span class="classifier">int | arraylike of ints | None</span></dt>
<dd>The index or indices of the physical or photometric
properties to be maginalized over, numbered from 0 -
nphys-1 for physical properties and from nphys - nfilter +
nfilter - 1 for photometric properties. If this keyword is
set, then physprop and/or photprop should have fewer
than nphys or nphot elements due to the omission of
marginalised dimensions. If all physical or photometric
dimensions are marginalised out, that corresponding
argument for physprop or photprop should be set to None</dd>
</dl>
</dd>
<dt>Returns</dt>
<dd><dl class="first last docutils">
<dt>logL <span class="classifier-delimiter">:</span> <span class="classifier">float or arraylike</span></dt>
<dd>natural log of the likelihood function</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="slugpy.bayesphot.bp.bp.make_approx_phot">
<code class="descname">make_approx_phot</code><span class="sig-paren">(</span><em>phys</em>, <em>squeeze=True</em>, <em>filter_ignore=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/slugpy/bayesphot/bp.html#bp.make_approx_phot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#slugpy.bayesphot.bp.bp.make_approx_phot" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an object that can be used for a fast approximation of
the PDF of photometric properties that corresponds to a set of
physical properties. The PDF produced by summing over the
points returned is guaranteed to account for at least 1-reltol
of the marginal photometric probability, and to represent the
shape of the PDF in photometric space within a local accuracy
of reltol as well.</p>
<dl class="docutils">
<dt>Parameters:</dt>
<dd><dl class="first last docutils">
<dt>phys <span class="classifier-delimiter">:</span> <span class="classifier">arraylike, shape (nphys) or (N, nphys)</span></dt>
<dd>the set or sets of physical properties for which the
approximation is to be generated</dd>
<dt>squeeze <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>if True, the representation returned will be squeezed to
minimize the number of points included, using reltol as
the error tolerance</dd>
<dt>filter_ignore <span class="classifier-delimiter">:</span> <span class="classifier">None or listlike of bool</span></dt>
<dd>if None, the kernel density representation returned
covers all filters; otherwise this must be a listlike of
bool, one entry per filter, with a value of False
indicating that filter should be excluded from the
values returned; suppressing filters can allow for more
efficient representations</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>x <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (M, nphot), or a list of such arrays</span></dt>
<dd>an array containing the list of points to be used for
the approximation, where nphot is the number of
photometric filters being returned</dd>
<dt>wgts <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (M), or a list of such arrays</span></dt>
<dd>an array containing the weights of the points</dd>
</dl>
</dd>
<dt>Notes:</dt>
<dd>if the requested relative tolerance cannot be reached for
numerical reasons (usually because the input point is too
far from the library to allow accurate computation), x and
wgts will be return as None, and a warning will be issued</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="slugpy.bayesphot.bp.bp.make_approx_phys">
<code class="descname">make_approx_phys</code><span class="sig-paren">(</span><em>phot</em>, <em>photerr=None</em>, <em>squeeze=True</em>, <em>phys_ignore=None</em>, <em>tol=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/slugpy/bayesphot/bp.html#bp.make_approx_phys"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#slugpy.bayesphot.bp.bp.make_approx_phys" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an object that can be used for a fast approximation of
the PDF of physical properties that corresponds to a set of
photometric properties. The PDF produced by summing over the
points returned is guaranteed to account for at least 1-reltol
of the marginal photometric probability, and to represent the
shape of the PDF in photometric space within a local accuracy
of reltol as well.</p>
<dl class="docutils">
<dt>Parameters:</dt>
<dd><dl class="first last docutils">
<dt>phot <span class="classifier-delimiter">:</span> <span class="classifier">arraylike, shape (nfilter) or (N, nfilter)</span></dt>
<dd>the set or sets of photometric properties for which the
approximation is to be generated</dd>
<dt>photerr <span class="classifier-delimiter">:</span> <span class="classifier">arraylike, shape (nfilter) or (N, nfilter)</span></dt>
<dd>array giving photometric errors; the number of elements
in the output lists will be the size that results from
broadcasting together the leading dimensions of phot and
photerr</dd>
<dt>squeeze <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>if True, the representation returned will be squeezed to
minimize the number of points included, using reltol as
the error tolerance</dd>
<dt>phys_ignore <span class="classifier-delimiter">:</span> <span class="classifier">None or listlike of bool</span></dt>
<dd>if None, the kernel density representation returned
covers all physical properties; otherwise this must be a
listlike of bool, one entry per physical dimension, with
a value of False indicating that dimension should be
excluded from the values returned; suppressing
dimensions can allow for more efficient representations</dd>
<dt>tol <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>if set, this tolerance overrides the value of reltol</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>x <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (M, nphys), or a list of such arrays</span></dt>
<dd>an array containing the list of points to be used for
the approximation, where nphys is the number of
physical dimensions being returned</dd>
<dt>wgts <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (M), or a list of such arrays</span></dt>
<dd>an array containing the weights of the points</dd>
</dl>
</dd>
<dt>Notes:</dt>
<dd>if the requested relative tolerance cannot be reached for
numerical reasons (usually because the input point is too
far from the library to allow accurate computation), x and
wgts will be return as None, and a warning will be issued</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="slugpy.bayesphot.bp.bp.make_cache">
<code class="descname">make_cache</code><span class="sig-paren">(</span><em>margindims</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/slugpy/bayesphot/bp.html#bp.make_cache"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#slugpy.bayesphot.bp.bp.make_cache" title="Permalink to this definition">¶</a></dt>
<dd><p>This method builds a cache to do faster calculation of PDFs
where certain dimensions are marginalised out. If such caches
exist, they are used automatically by all the computation
methods.</p>
<dl class="docutils">
<dt>Parameters</dt>
<dd><dl class="first last docutils">
<dt>margindims <span class="classifier-delimiter">:</span> <span class="classifier">listlike of integers</span></dt>
<dd>list of dimensions to be marginalised out; physical
dimensions go from 0 - nphys-1, photometric dimensions
from nphys to nphys + nphot - 1</dd>
</dl>
</dd>
<dt>Returns</dt>
<dd>Nothing</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="slugpy.bayesphot.bp.bp.mcmc">
<code class="descname">mcmc</code><span class="sig-paren">(</span><em>photprop</em>, <em>photerr=None</em>, <em>mc_walkers=100</em>, <em>mc_steps=500</em>, <em>mc_burn_in=50</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/slugpy/bayesphot/bp.html#bp.mcmc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#slugpy.bayesphot.bp.bp.mcmc" title="Permalink to this definition">¶</a></dt>
<dd><p>This function returns a sample of MCMC walkers sampling the
physical parameters at a specified set of photometric values.</p>
<dl class="docutils">
<dt>Parameters:</dt>
<dd><dl class="first last docutils">
<dt>photprop <span class="classifier-delimiter">:</span> <span class="classifier">arraylike, shape (nfilter) or (…, nfilter)</span></dt>
<dd>array giving the photometric values; for a
multidimensional array, the operation is vectorized over
the leading dimensions</dd>
<dt>photerr <span class="classifier-delimiter">:</span> <span class="classifier">arraylike, shape (nfilter) or (…, nfilter)</span></dt>
<dd>array giving photometric errors; for a multidimensional
array, the operation is vectorized over the leading
dimensions</dd>
<dt>mc_walkers <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of walkers to use in the MCMC</dd>
<dt>mc_steps <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of steps in the MCMC</dd>
<dt>mc_burn_in <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of steps to consider “burn-in” and discard</dd>
</dl>
</dd>
<dt>Returns</dt>
<dd><dl class="first last docutils">
<dt>samples <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd>array of sample points returned by the MCMC</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="slugpy.bayesphot.bp.bp.mpdf">
<code class="descname">mpdf</code><span class="sig-paren">(</span><em>idx</em>, <em>photprop</em>, <em>photerr=None</em>, <em>ngrid=128</em>, <em>qmin=None</em>, <em>qmax=None</em>, <em>grid=None</em>, <em>norm=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/slugpy/bayesphot/bp.html#bp.mpdf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#slugpy.bayesphot.bp.bp.mpdf" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the marginal probability for one or mode physical
quantities for one or more input sets of photometric
properties. Output quantities are computed on a grid of
values, in the same style as meshgrid.</p>
<dl class="docutils">
<dt>Parameters:</dt>
<dd><dl class="first last docutils">
<dt>idx <span class="classifier-delimiter">:</span> <span class="classifier">int or listlike containing ints</span></dt>
<dd>index of the physical quantity whose PDF is to be
computed; if this is an iterable, the joint distribution of
the indicated quantities is returned</dd>
<dt>photprop <span class="classifier-delimiter">:</span> <span class="classifier">arraylike, shape (nfilter) or (…, nfilter)</span></dt>
<dd>array giving the photometric values; for a
multidimensional array, the operation is vectorized over
the leading dimensions</dd>
<dt>photerr <span class="classifier-delimiter">:</span> <span class="classifier">arraylike, shape (nfilter) or (…, nfilter)</span></dt>
<dd>array giving photometric errors; for a multidimensional
array, the operation is vectorized over the leading
dimensions</dd>
<dt>ngrid <span class="classifier-delimiter">:</span> <span class="classifier">int or listlike containing ints</span></dt>
<dd>number of points in each dimension of the output grid;
if this is an iterable, it must have the same number of
elements as idx</dd>
<dt>qmin <span class="classifier-delimiter">:</span> <span class="classifier">float or listlike</span></dt>
<dd>minimum value in the output grid in each quantity; if
left as None, defaults to the minimum value in the
library; if this is an iterable, it must contain the
same number of elements as idx</dd>
<dt>qmax <span class="classifier-delimiter">:</span> <span class="classifier">float or listlike</span></dt>
<dd>maximum value in the output grid in each quantity; if
left as None, defaults to the maximum value in the
library; if this is an iterable, it must contain the
same number of elements as idx</dd>
<dt>grid <span class="classifier-delimiter">:</span> <span class="classifier">listlike of arrays</span></dt>
<dd>set of values defining the grid on which the PDF is to
be evaluated, in the same format used by meshgrid</dd>
<dt>norm <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>if True, returned pdf’s will be normalized to integrate
to 1</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>grid_out <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd>array of values at which the PDF is evaluated; contents
are the same as returned by meshgrid</dd>
<dt>pdf <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd>array of marginal posterior probabilities at each point
of the output grid, for each input set of photometry; the leading
dimensions match the leading dimensions produced by
broadcasting the leading dimensions of photprop and
photerr together, while the trailing dimensions match
the dimensions of the output grid</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="slugpy.bayesphot.bp.bp.mpdf_approx">
<code class="descname">mpdf_approx</code><span class="sig-paren">(</span><em>x</em>, <em>wgts</em>, <em>dims='phys'</em>, <em>dims_return=None</em>, <em>ngrid=64</em>, <em>qmin='all'</em>, <em>qmax='all'</em>, <em>grid=None</em>, <em>norm=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/slugpy/bayesphot/bp.html#bp.mpdf_approx"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#slugpy.bayesphot.bp.bp.mpdf_approx" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the marginal posterior PDF computed from a kernel
density approximation returned by make_approx_phys or
make_approx_phot. Outputs are computed on a grid of values, in
the same style as meshgrid.</p>
<dl class="docutils">
<dt>Parameters:</dt>
<dd><dl class="first last docutils">
<dt>x <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (M, ndim), or a list of such arrays</span></dt>
<dd>array of points retured by make_approx_phot or
make_approx_phys</dd>
<dt>wgts <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (M) or a list of such arrays</span></dt>
<dd>array of weights returned by make_approx_phot or
make_approx_phys</dd>
<dt>dims <span class="classifier-delimiter">:</span> <span class="classifier">‘phys’ | ‘phot’ | arraylike of ints</span></dt>
<dd>dimensions covered by x and wgts; the strings ‘phys’ or
‘phot’ indicate that they cover all physical or
photometric dimensions, and correspond to the defaults
returned by make_approx_phys and make_approx_phot,
respectively; if dims is an array of ints, these specify
the dimensions covered by x and wgts, where the
physical dimensions are numbered 0, 1, … nphys-1, and
the photometric ones are nphys, nphys+1,
… nphys+nphot-1</dd>
<dt>dims_return <span class="classifier-delimiter">:</span> <span class="classifier">None or arraylike of ints</span></dt>
<dd>if None, the output PDF has the same dimensions as
specified in dms; if not, then dimreturn must be a
subset of dim, and a marginal PDF in certain dimensions
will be generated</dd>
<dt>ngrid <span class="classifier-delimiter">:</span> <span class="classifier">int or listlike containing ints</span></dt>
<dd>number of points in each dimension of the output grid;
if this is an iterable, it must have the same number of
elements as idx</dd>
<dt>qmin <span class="classifier-delimiter">:</span> <span class="classifier">float | listlike | ‘zoom’ | ‘all’ </span></dt>
<dd>minimum value in the output grid in each quantity; if
this a float, it is applied to each dimension; if it is
an iterable, it must contain the same number of elements
as the number of dimensions being returned, as gives the
minimum in each dimension; if it is ‘zoom’ or ‘all’, the
minimum is chosen automatically, with ‘zoom’ focusing on
a region encompassing the probability maximum, and ‘all’
encompassing all the points in the representation</dd>
<dt>qmax <span class="classifier-delimiter">:</span> <span class="classifier">float | listlike | ‘zoom’ | ‘all’</span></dt>
<dd>same as qmin, but for the maximum of the output grid</dd>
<dt>grid <span class="classifier-delimiter">:</span> <span class="classifier">listlike of arrays</span></dt>
<dd>set of values defining the grid on which the PDF is to
be evaluated, in the same format used by meshgrid</dd>
<dt>norm <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>if True, returned pdf’s will be normalized to integrate
to 1</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>grid_out <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd>array of values at which the PDF is evaluated; contents
are the same as returned by meshgrid</dd>
<dt>pdf <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd>array of marginal posterior probabilities at each point
of the output grid, for each input cluster; the leading
dimensions match the leading dimensions produced by
broadcasting the leading dimensions of photprop and
photerr together, while the trailing dimensions match
the dimensions of the output grid</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="slugpy.bayesphot.bp.bp.mpdf_gen">
<code class="descname">mpdf_gen</code><span class="sig-paren">(</span><em>fixeddim</em>, <em>fixedprop</em>, <em>margindim</em>, <em>ngrid=128</em>, <em>qmin=None</em>, <em>qmax=None</em>, <em>grid=None</em>, <em>norm=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/slugpy/bayesphot/bp.html#bp.mpdf_gen"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#slugpy.bayesphot.bp.bp.mpdf_gen" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the marginal probability for one or more physical or
photometric properties, keeping other properties fixed and
marginalizing over other quantities. This is the most general
marginal PDF routine provided.</p>
<dl class="docutils">
<dt>Parameters:</dt>
<dd><dl class="first last docutils">
<dt>fixeddim <span class="classifier-delimiter">:</span> <span class="classifier">int | arraylike of ints | None</span></dt>
<dd>The index or indices of the physical or photometric
properties to be held fixed; physical properties are
numbered 0 … nphys-1, and phtometric ones are numbered
nphys … nphys + nphot - 1. This can also be set to
None, in which case no properties are held fixed.</dd>
<dt>fixedprop <span class="classifier-delimiter">:</span> <span class="classifier">array | None</span></dt>
<dd>The values of the properties being held fixed; the size
of the final dimension must be equal to the number of
elements in fixeddim, and if fixeddim is None, this must
be too</dd>
<dt>margindim <span class="classifier-delimiter">:</span> <span class="classifier">int | arraylike of ints | None</span></dt>
<dd>The index or indices of the physical or photometric
properties to be maginalized over, numbered in the same
way as with fixeddim; if set to None, no marginalization
is performed</dd>
<dt>ngrid <span class="classifier-delimiter">:</span> <span class="classifier">int or listlike containing ints</span></dt>
<dd>number of points in each dimension of the output grid;
if this is an iterable, it must have nphys + nphot -
len(fixeddim) - len(margindim) elements</dd>
<dt>qmin <span class="classifier-delimiter">:</span> <span class="classifier">float | arraylike</span></dt>
<dd>minimum value in the output grid in each quantity; if
left as None, defaults to the minimum value in the
library; if this is an iterable, it must contain a
number of elements equal to nphys + nphot -
len(fixeddim) - len(margindim)</dd>
<dt>qmax <span class="classifier-delimiter">:</span> <span class="classifier">float | arraylike</span></dt>
<dd>maximum value in the output grid in each quantity; if
left as None, defaults to the maximum value in the
library; if this is an iterable, it must have the same
number of elements as qmin</dd>
<dt>grid <span class="classifier-delimiter">:</span> <span class="classifier">listlike of arrays</span></dt>
<dd>set of values defining the grid on which the PDF is to
be evaluated, in the same format used by meshgrid</dd>
<dt>norm <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>if True, returned pdf’s will be normalized to integrate
to 1</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>grid_out <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd>array of values at which the PDF is evaluated; contents
are the same as returned by meshgrid</dd>
<dt>pdf <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd>array of marginal posterior probabilities at each point
of the output grid, for each input set of properties; the leading
dimensions match the leading dimensions produced by
broadcasting the leading dimensions of photprop and
photerr together, while the trailing dimensions match
the dimensions of the output grid</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="slugpy.bayesphot.bp.bp.mpdf_phot">
<code class="descname">mpdf_phot</code><span class="sig-paren">(</span><em>idx</em>, <em>physprop</em>, <em>ngrid=128</em>, <em>qmin=None</em>, <em>qmax=None</em>, <em>grid=None</em>, <em>norm=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/slugpy/bayesphot/bp.html#bp.mpdf_phot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#slugpy.bayesphot.bp.bp.mpdf_phot" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the marginal probability for one or mode photometric
quantities corresponding to an input set of physical
properties. Output quantities are computed on a grid of
values, in the same style as meshgrid.</p>
<dl class="docutils">
<dt>Parameters:</dt>
<dd><dl class="first last docutils">
<dt>idx <span class="classifier-delimiter">:</span> <span class="classifier">int or listlike containing ints</span></dt>
<dd>index of the photometric quantity whose PDF is to be
computed, starting at 0; if this is an iterable, the
joint distribution of the indicated quantities is returned</dd>
<dt>physprop <span class="classifier-delimiter">:</span> <span class="classifier">arraylike, shape (nphys) or (…, nphys)</span></dt>
<dd>physical properties to be used; if this is an array of
nphys elements, these give the physical properties; if
it is a multidimensional array, the operation is
vectorized over the leading dimensions
physical properties – the function must take an array
of (nphys) elements as an input, and return a floating
point value representing the PDF evaluated at that set
of physical properties as an output</dd>
<dt>ngrid <span class="classifier-delimiter">:</span> <span class="classifier">int or listlike containing ints</span></dt>
<dd>number of points in each dimension of the output grid;
if this is an iterable, it must have the same number of
elements as idx</dd>
<dt>qmin <span class="classifier-delimiter">:</span> <span class="classifier">float or listlike</span></dt>
<dd>minimum value in the output grid in each quantity; if
left as None, defaults to the minimum value in the
library; if this is an iterable, it must contain the
same number of elements as idx</dd>
<dt>qmax <span class="classifier-delimiter">:</span> <span class="classifier">float or listlike</span></dt>
<dd>maximum value in the output grid in each quantity; if
left as None, defaults to the maximum value in the
library; if this is an iterable, it must contain the
same number of elements as idx</dd>
<dt>grid <span class="classifier-delimiter">:</span> <span class="classifier">listlike of arrays</span></dt>
<dd>set of values defining the grid on which the PDF is to
be evaluated, in the same format used by meshgrid</dd>
<dt>norm <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>if True, returned pdf’s will be normalized to integrate
to 1</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>grid_out <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd>array of values at which the PDF is evaluated; contents
are the same as returned by meshgrid</dd>
<dt>pdf <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd>array of marginal posterior probabilities at each point
of the output grid, for each input set of properties; the leading
dimensions match the leading dimensions produced by
broadcasting the leading dimensions of photprop and
photerr together, while the trailing dimensions match
the dimensions of the output grid</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="slugpy.bayesphot.bp.bp.ndim">
<code class="descname">ndim</code><a class="headerlink" href="#slugpy.bayesphot.bp.bp.ndim" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the number of physical plus photometric properties for
the bayesphot object.</p>
</dd></dl>

<dl class="attribute">
<dt id="slugpy.bayesphot.bp.bp.nphot">
<code class="descname">nphot</code><a class="headerlink" href="#slugpy.bayesphot.bp.bp.nphot" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the number of photometric properties for the bayesphot
object.</p>
</dd></dl>

<dl class="attribute">
<dt id="slugpy.bayesphot.bp.bp.nphys">
<code class="descname">nphys</code><a class="headerlink" href="#slugpy.bayesphot.bp.bp.nphys" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the number of physical properties for the bayesphot
object.</p>
</dd></dl>

<dl class="attribute">
<dt id="slugpy.bayesphot.bp.bp.pobs">
<code class="descname">pobs</code><a class="headerlink" href="#slugpy.bayesphot.bp.bp.pobs" title="Permalink to this definition">¶</a></dt>
<dd><p>The current set of observation probabilities for every
simulation in the library; data returned are in the same order
as the data originally used to construct the library</p>
</dd></dl>

<dl class="attribute">
<dt id="slugpy.bayesphot.bp.bp.priors">
<code class="descname">priors</code><a class="headerlink" href="#slugpy.bayesphot.bp.bp.priors" title="Permalink to this definition">¶</a></dt>
<dd><p>The current set of prior probabilities for every
simulation in the library; data returned are in the same order
as the data originally used to construct the library</p>
</dd></dl>

<dl class="attribute">
<dt id="slugpy.bayesphot.bp.bp.sample_density">
<code class="descname">sample_density</code><a class="headerlink" href="#slugpy.bayesphot.bp.bp.sample_density" title="Permalink to this definition">¶</a></dt>
<dd><p>The density with which the library was sampled, evaluated for
each simulation in the library</p>
</dd></dl>

<dl class="method">
<dt id="slugpy.bayesphot.bp.bp.squeeze_rep">
<code class="descname">squeeze_rep</code><span class="sig-paren">(</span><em>x</em>, <em>wgts</em>, <em>dims=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/slugpy/bayesphot/bp.html#bp.squeeze_rep"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#slugpy.bayesphot.bp.bp.squeeze_rep" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes an input array of positions and weights that form a
kernel density representation and approximates them using
fewer points, using an error tolerance of reltol</p>
<dl class="docutils">
<dt>Parameters:</dt>
<dd><dl class="first last docutils">
<dt>x <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (N, ndim)</span></dt>
<dd>an array of points forming a kernel density
representation; on exit, x will be resized to (M, ndim)
with M &lt;= N</dd>
<dt>wgts <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (N)</span></dt>
<dd>an array of weights for the kernel density
representation; on exit, wgts will be resized to (M),
with M &lt;= N</dd>
<dt>dims <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (ndim)</span></dt>
<dd>array specifying which dimensions in the kernel density
representation the coordinates in x correspond to; if
left as None, they are assumed to correspond to the
first ndim dimensions in the data set</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>Nothing</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">bayesphot: Bayesian Inference for Stochastic Stellar Populations</a><ul>
<li><a class="reference internal" href="#what-does-bayesphot-do">What Does bayesphot Do?</a></li>
<li><a class="reference internal" href="#creating-bp-objects">Creating <code class="docutils literal"><span class="pre">bp</span></code> Objects</a></li>
<li><a class="reference internal" href="#using-bp-objects">Using <code class="docutils literal"><span class="pre">bp</span></code> Objects</a></li>
<li><a class="reference internal" href="#caching">Caching</a></li>
<li><a class="reference internal" href="#parallelism-in-bayesphot">Parallelism in bayesphot</a></li>
<li><a class="reference internal" href="#module-slugpy.bayesphot.bp">Full Documentation of slugpy.bayesphot</a></li>
</ul>
</li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="cloudy.html" title="previous chapter">cloudy_slug: An Automated Interface to cloudy</a></li>
      <li>Next: <a href="cluster_slug.html" title="next chapter">cluster_slug: Bayesian Inference of Star Cluster Properties</a></li>
  </ul></li>
</ul>
</div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/bayesphot.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2014, Mark Krumholz, Michele Fumagalli, et al..
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.6.3</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.6</a>
      
      |
      <a href="_sources/bayesphot.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>